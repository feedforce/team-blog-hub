{"pageProps":{"member":{"name":"feedforce","bio":"Feedforce Developer Blog","avatarSrc":"/avatars/feedforce.jpg","sources":["https://developer.feedforce.jp/rss"]},"postItems":[{"title":"Amazon EKS で高負荷時に CoreDNS が原因で稀にネットワークエラーが発生していた時のトラブルシュート","content":"<p>ソーシャルPLUS の開発チームでインフラエンジニア をやっています <a href=\"http://blog.hatena.ne.jp/mayuki123/\" class=\"hatena-id-icon\"><img src=\"https://cdn.profile-image.st-hatena.com/users/mayuki123/profile.png\" width=\"16\" height=\"16\" alt=\"\" class=\"hatena-id-icon\">id:mayuki123</a> です。今月からフィードフォースから分社化をした株式会社ソーシャルPLUS の所属となりましたが、仕事内容は変わらずにサービスのインフラ改善を進めていく事になるかと思います。</p>\n\n<p>2019年11月に技術スタックを整理してみたという記事から2年弱経過していますが、ソーシャルPLUSのインフラ環境は、一部アプリケーションについてはコンテナ環境を Amazon EKS にホスティングして本番運用するようになりました。あと数ヶ月ほどで全ての環境がEC2からコンテナに置き換えられると良いなと思っています(願望)。</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fdeveloper.feedforce.jp%2Fentry%2F2019%2F11%2F25%2F120000\" title=\"ソーシャルPLUS の技術スタックを整理してみた - Feedforce Developer Blog\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://developer.feedforce.jp/entry/2019/11/25/120000\">developer.feedforce.jp</a></cite></p>\n\n<p>そして、既に利用されている機能の一部を Amazon EKS に移行して、しばらく経過した時にアプリケーションでネットワークエラーが稀に発生していました。原因調査をした結果が CoreDNS の負荷によるものと発覚するまでのトラブルシュートの流れについて、記事として書き残しておきます。</p>\n\n<ul class=\"table-of-contents\">\n    <li><a href=\"#発生していた事象\">発生していた事象</a></li>\n    <li><a href=\"#Datadog-を活用した原因調査\">Datadog を活用した原因調査</a><ul>\n            <li><a href=\"#アプリケーションの負荷状況\">アプリケーションの負荷状況</a></li>\n            <li><a href=\"#EKS-上のコンテナの調査\">EKS 上のコンテナの調査</a></li>\n        </ul>\n    </li>\n    <li><a href=\"#EKS-のCoreDNS-の調査\">EKS のCoreDNS の調査</a><ul>\n            <li><a href=\"#CoreDNS-のデバッグログの有効化\">CoreDNS のデバッグログの有効化</a></li>\n            <li><a href=\"#Kubernetes-の名前解決について\">Kubernetes の名前解決について</a></li>\n        </ul>\n    </li>\n    <li><a href=\"#CoreDNS-の負荷軽減\">CoreDNS の負荷軽減</a><ul>\n            <li><a href=\"#ドメインの末尾にドット--を追加する\">ドメインの末尾にドット (.) を追加する</a></li>\n            <li><a href=\"#etcresolvconf-で-ndots1-の設定をする\">/etc/resolv.conf で ndots:1 の設定をする</a></li>\n            <li><a href=\"#その他の-CoreDNS-の負荷軽減の方法\">その他の CoreDNS の負荷軽減の方法</a></li>\n        </ul>\n    </li>\n    <li><a href=\"#最終的な結果\">最終的な結果</a></li>\n    <li><a href=\"#おわりに\">おわりに</a></li>\n    <li><a href=\"#おまけ\">おまけ</a></li>\n</ul>\n\n<h2 id=\"発生していた事象\">発生していた事象</h2>\n\n<p>ソーシャルPLUSでは、バックエンドのアプリケーションでエラーが発生した時に、Bugsnag を利用して Slack 通知するようにしています。ある時に<code>Mysql2::Error::ConnectionError</code> が発生しました。単発のネットワークエラーの場合はアプリケーションがリトライする事でサービス影響がない事も多く、一時的な問題と思って静観する事があるかと思います。しかし、また数日後に同じ事象が発生しました。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/m/mayuki123/20210830/20210830152912.png\" alt=\"f:id:mayuki123:20210830152912p:plain\" width=\"667\" height=\"258\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p><a href=\"https://ja.wikipedia.org/wiki/%E3%83%8F%E3%82%A4%E3%83%B3%E3%83%AA%E3%83%83%E3%83%92%E3%81%AE%E6%B3%95%E5%89%87\">ハインリッヒの1：29：300の法則</a>のように、ちょっとした異常を見落としていると重大なサービス障害となってしまう可能性があるので、原因調査を始めます。</p>\n\n<h2 id=\"Datadog-を活用した原因調査\">Datadog を活用した原因調査</h2>\n\n<p>ソーシャルPLUSでは、モニタリングサービスの Datadog を利用しているのでメトリクスやログの調査を出来るようになっています。どこが原因かを探り始めました。</p>\n\n<h3 id=\"アプリケーションの負荷状況\">アプリケーションの負荷状況</h3>\n\n<p>まずはアプリケーションで利用するサーバの負荷状況を確認する所から始めました。<code>Mysql2::Error::ConnectionError</code> が発生した時刻は EKS の Node の CPU 使用率が 70% ほどで、アプリケーションで負荷のかかる処理の最中でした。また、データベースの負荷は少し前に負荷対策の改善をした事もあって、今回の事件の犯人ではなさそうです。他にもEC2 と DB 間でネットワークのボトルネックがないかなどの確認はしましたが、CPU 使用率が高い以外の問題は特に見つかりませんでした。完全犯罪でしょうか。</p>\n\n<h3 id=\"EKS-上のコンテナの調査\">EKS 上のコンテナの調査</h3>\n\n<p>サーバ単体の問題ではないとすると、Amazon EKS で何か起きている事を疑うことにしました。EKSで動かしているコンテナのログは Datadog Logs に送っているので、<strong>エラーが発生していたアプリケーション以外のログ</strong> を確認していると、MySQL の ConnectionError が発生した時間帯に下記の Warning のメッセージが出ている事に気づきました。このログは Amazon Kinesis Data Firehose にログを送る Fluent Bit のコンテナで発生しており、エラーが発生してたアプリケーションとは異なるノードに存在してました。</p>\n\n<blockquote><p>[yyyy/mm/dd hh:mm:ss] [ warn] [net] getaddrinfo(host='kinesis.ap-northeast-1.amazonaws.com'): Name or service not known</p></blockquote>\n\n<p>同時刻に特定のアプリケーション以外のコンテナも影響を受けていることから、EKS の中で問題がありそうです。元々、EKSに関する技術ブログは目を通すようにしていた事もあり、Kubernetes の DNS の名前解決で問題が発生する場合があるというのは知っていたので、CoreDNSに焦点を当てて調べることにしました。アウトプットをしてくれる人たちには、いつも感謝をしています。</p>\n\n<ul>\n<li><a href=\"https://medium.com/cloutive/production-ready-eks-coredns-configuration-6fea830606f8\">Production Ready EKS CoreDNS Configuration | by Serkan Capkan | Cloutive Technology Solutions - Tech Blog | Medium</a></li>\n<li><a href=\"https://creators-note.chatwork.com/entry/2021/01/05/104206#%E4%B8%80%E5%AE%9A%E6%95%B0%E3%81%AEPod%E4%BB%A5%E4%B8%8A%E3%81%AB%E3%81%AA%E3%82%8B%E3%81%A8%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%8C%E4%B8%8D%E5%AE%89%E5%AE%9A%E3%81%AB%E3%81%AA%E3%82%8B\">EKS&#x3067;DNS&#x3092;&#x5B89;&#x5B9A;&#x3055;&#x305B;&#x308B;&#x305F;&#x3081;&#x306B;&#x5BFE;&#x5FDC;&#x3057;&#x305F;&#x3053;&#x3068; - Chatwork Creator&#39;s Note</a></li>\n<li><a href=\"https://labs.gree.jp/blog/2020/01/20271/\">&#x30B9;&#x30DE;&#x30DB;&#x30B2;&#x30FC;&#x30E0;&#x306E; API &#x30B5;&#x30FC;&#x30D0;&#x306B;&#x304A;&#x3051;&#x308B; EKS &#x306E;&#x904B;&#x7528;&#x4E8B;&#x4F8B; | &#x30A8;&#x30F3;&#x30B8;&#x30CB;&#x30A2;&#x30D6;&#x30ED;&#x30B0; | GREE Engineering</a></li>\n</ul>\n\n\n<h2 id=\"EKS-のCoreDNS-の調査\">EKS のCoreDNS の調査</h2>\n\n<p>Datadog Agent で Kurbernetes の各種メトリクスを収集していて、EKS の CoreDNS の状況も Datadog の Metric Explorer で確認する事が出来るようになっています。</p>\n\n<ul>\n<li><a href=\"https://docs.datadoghq.com/ja/integrations/coredns/?tab=docker#%E3%83%A1%E3%83%88%E3%83%AA%E3%82%AF%E3%82%B9\">Datadog で取得可能な CoreDNS のメトリクス</a></li>\n</ul>\n\n\n<p><code>coredns.request_count</code> を確認すると特定の時間帯で CoreDNS へのリクエストが多い状態で、このタイミングでの CoreDNS Pod の CPU 負荷は10％前後でしたが、それ以外に不審なメトリクスは存在しませんでした。まだ事象の原因との確信は持てないですが、負荷がそれなりにかかっていることは確かなのでリクエストが多くなる理由を調べます。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/m/mayuki123/20210831/20210831151005.png\" alt=\"f:id:mayuki123:20210831151005p:plain\" width=\"522\" height=\"200\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<h3 id=\"CoreDNS-のデバッグログの有効化\">CoreDNS のデバッグログの有効化</h3>\n\n<p>まずは CoreDNS のデバッグログを確認したいとなるかと思いますが、EKS の CoreDNS はデフォルトだとデバッグログの出力がオフの状態のため、どのようなリクエストが到達しているのかは確認する事ができません。CoreDNS のログを有効化する方法は AWS のナレッジベースにある記事に方法が記載されています。</p>\n\n<ul>\n<li><a href=\"https://aws.amazon.com/jp/premiumsupport/knowledge-center/eks-dns-failure/\">Amazon EKS &#x3067;&#x306E; DNS &#x969C;&#x5BB3;&#x306E;&#x30C8;&#x30E9;&#x30D6;&#x30EB;&#x30B7;&#x30E5;&#x30FC;&#x30C6;&#x30A3;&#x30F3;&#x30B0;</a></li>\n</ul>\n\n\n<p>この記事によると、Namespace(<code>kube-system</code>) に Configmap (<code>coredns</code>) があるので、Corefile 設定に <code>log</code> を追加するとデバッグログ が出力されるようになります。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink># kubectl -n kube-system edit configmap coredns\nkind: ConfigMap\napiVersion: v1\ndata:\n  Corefile: |\n    .:53 {\n        log    # Enabling CoreDNS Logging\n        errors\n        health\n        kubernetes cluster.local in-addr.arpa ip6.arpa {\n          pods insecure\n          upstream\n          fallthrough in-addr.arpa ip6.arpa\n        }\n        ...</pre>\n\n\n<p>上記の設定をすると CoreDNS のPod の標準出力にデバッグログ が出力されるようになります。私の触っていた EKS の環境の場合は、数分ほどで CoreDNS の Pod で reload が発生して元の設定（デバッグログ がオフ）に戻るようになってました。</p>\n\n<h3 id=\"Kubernetes-の名前解決について\">Kubernetes の名前解決について</h3>\n\n<p>次にKubernetes 上のコンテナはどのように名前解決するのかを知っておく必要があります。Kurbernetes の Pod の DNS リゾルバー(<code>/etc/resolv.conf</code>) のデフォルト設定は下記のようになっています。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>% kubectl exec fluent-bit-46zvl -- cat /etc/resolv.conf\nnameserver 172.20.0.10\nsearch logging.svc.cluster.local svc.cluster.local cluster.local\noptions ndots:5</pre>\n\n\n<p>この状態で Fluent Bit のコンテナから Amazon Kinesis の API エンドポイントに疎通する場合は、CoreDNS に8回のリクエストが発生します。これは、IPv4 , IPv6 の2種類の名前解決を <code>search</code> の数だけ名前解決を試みた後で EKS 外に名前解決をする設定になっているからです。この設定になっているおかげで Kubernetes の Service を使った名前解決が出来るようになっています。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/m/mayuki123/20210831/20210831154909.png\" alt=\"f:id:mayuki123:20210831154909p:plain\" width=\"1200\" height=\"328\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>また、<code>options ndots:5</code> の設定は <code>.</code> の数が 5個以上の時は最初から外部に名前解決するようになります。そのため、Amazon Aurora や ElastiCache などのデータベースへの クラスターエンドポイントは <code>.</code> の数が五個以上あるので、CoreDNSへのリクエスト回数は少なくて済みます。ここを意識しなくてよいのはありがたいですね。</p>\n\n<p>ソーシャルPLUSというプロダクトの特性上、EKS 内のアプリケーションから外部サービスの API を実行する機会が多々あります。特定のタイミングで外部のサービスに大量のAPIリクエストを実行した際に、CoreDNS へのリクエストが増大してしまい不安定になってしまったのではと考えられます。</p>\n\n<h2 id=\"CoreDNS-の負荷軽減\">CoreDNS の負荷軽減</h2>\n\n<p>Kurbernetes 上のコンテナの名前解決を知ると、外部サービスのAPI を実行する際には CoreDNS へのリクエストが多くなる事が分かりました。ここで、CoreDNS へのリクエスト数を減らす方法は下記の二つがあります。これも AWS のナレッジベースに方法が記載されているので、詳細は下記の記事を読む方が良いと思います。</p>\n\n<ul>\n<li><a href=\"https://aws.amazon.com/jp/premiumsupport/knowledge-center/eks-dns-failure/\">Amazon EKS &#x3067;&#x306E; DNS &#x969C;&#x5BB3;&#x306E;&#x30C8;&#x30E9;&#x30D6;&#x30EB;&#x30B7;&#x30E5;&#x30FC;&#x30C6;&#x30A3;&#x30F3;&#x30B0;</a></li>\n</ul>\n\n\n<h3 id=\"ドメインの末尾にドット--を追加する\">ドメインの末尾にドット (.) を追加する</h3>\n\n<p>接続先のドメインの最後に <code>.</code> をつけると、EKS の内部で名前解決を複数回しないようになり、CoreDNS へのリクエストの総数が減ります。一例をあげると、<code>example.com</code> ではなく、 <code>example.com.</code> とする事で最初から EKS の外部に名前解決をしてくれるようになります。ドメインが SDK の内部で定義されているような場合など、変更出来ない場合はこの方法は利用出来ないかと思います。</p>\n\n<h3 id=\"etcresolvconf-で-ndots1-の設定をする\"><code>/etc/resolv.conf</code> で ndots:1 の設定をする</h3>\n\n<p><code>/etc/resolv.conf</code> に <code>options ndots:5</code> とデフォルトで設定されている数値を <code>1</code> にする事で、ドメインに <code>.</code> が含まれている場合は常に EKS の外部に名前解決するようになります。Kubernetes の Manifest に <code>spec.dnsConfig</code> パラメータを設定する事で Pod 単位で変更が出来ます。ただし、この設定をすると EKS 内部で名前解決をしなくなってしまいますが、<code>&lt;name&gt;.&lt;namespace&gt;.svc.cluster.local.</code> のように最後に <code>.</code> をつけると名前解決出来ました。Kurbernetes の Service の数が多いとこの方法を周知させるのも大変だと思います。</p>\n\n<pre class=\"code\" data-lang=\"\" data-unlink>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: hoge\nspec:\n  template:\n    spec:\n      dnsConfig:\n        options:\n          - name: ndots\n            value: &#34;1&#34;</pre>\n\n\n<h3 id=\"その他の-CoreDNS-の負荷軽減の方法\">その他の CoreDNS の負荷軽減の方法</h3>\n\n<p>上記の二つの方法は CoreDNS へのリクエスト数を減らすことで、負荷を軽減するようなアプローチでした。CoreDNS の Pod 数はデフォルトで 2個となりますが、CoreDNS のPod をオートスケールする手段もあります。</p>\n\n<ul>\n<li><a href=\"https://kubernetes.io/docs/tasks/administer-cluster/dns-horizontal-autoscaling/\">Autoscale the DNS Service in a Cluster</a></li>\n</ul>\n\n\n<p>また、Daemonset で DNS キャッシュをノード単位で配置するという方法もあります。</p>\n\n<ul>\n<li><a href=\"https://kubernetes.io/ja/docs/tasks/administer-cluster/nodelocaldns/\">KubernetesクラスターでNodeLocal DNSキャッシュを使用する</a></li>\n</ul>\n\n\n<p>この辺りは他の方が書いた技術ブログも多くあるかと思うので、この記事では特に説明はしないです。</p>\n\n<h2 id=\"最終的な結果\">最終的な結果</h2>\n\n<p>ソーシャルPLUSでは最終的に根本原因の CoreDNS へのリクエスト数を減らすために <code>/etc/resolv.conf</code> で <code>ndots:1</code> の設定をするようにしました。この設定をアプリケーションの Pod に適応した所、CoreDNS へのリクエスト数は 25% ほどと目に見えて減少させる事が出来ました。キャプチャは載せてないですが、CoreDNS の Pod の CPU使用率も 以前の半分ほどになったので、負荷軽減の目的は達成しました。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/m/mayuki123/20210831/20210831171734.png\" alt=\"f:id:mayuki123:20210831171734p:plain\" width=\"527\" height=\"187\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>ここまで、確信を持てないまま CoreDNS の負荷軽減に取り組みましたが、元々のネットワークエラーであった <code>Mysql2::Error::ConnectionError</code> のエラーは再発しなくなりました。また、EKS 上の他のコンテナも <code>Name or service not known</code> のような名前解決が出来ないといったエラーも発生しなくなりました。CoreDNS の負荷を減らす事で悩まされていた問題の解消が出来たと思います。今回のように比較的早い段階で気づく事が出来たので、お客さんへのサービス影響のある問題に発展せずに済みました。</p>\n\n<p>今後、利用者数が増えてより負荷のかかる状況になってきた時には再発する可能性はありますが、早い段階で気付けるように日々確認するダッシュボードにメトリクスを追加するようにしています。その時がきた場合は CoreDNS の Pod 数の調整や DNS キャッシュの導入が必要になりそうです。</p>\n\n<h2 id=\"おわりに\">おわりに</h2>\n\n<p>最終的には Pod の DNS 設定を調整するだけでネットワークエラーは解決しました。この記事では、結果だけではなくて解決に至るまでの経緯をメインにまとめてみました。実施していて良かったと思うことを下記にまとめます。これらの事が出来ていなければ、今回のようなネットワークエラーはたまに発生する事象として、根本原因の追及は出来なかったと思うので、サービスのオブザーバビリティを整備する事や日々の情報収集は大事ですね。</p>\n\n<ul>\n<li>アプリケーションのエラーを Slack に通知していた</li>\n<li>Kurbernetes のメトリクスを Datadog で確認できる状態だった</li>\n<li>コンテナのログを一元的に Datadog Logs  で閲覧できるようにしていた</li>\n<li>他の人の技術ブログから Kubernetes の CoreDNS が不安定になることを知っていた</li>\n</ul>\n\n\n<p>この記事に間違っている内容や、もっと良い改善方法がある事をご存知の方がいましたら、優しく教えてください。</p>\n\n<h2 id=\"おまけ\">おまけ</h2>\n\n<p>現在、ソーシャルPLUS では作りたい機能が山ほどある状況でまだまだ成長するサービスになると思うので、成長を続けるサービスに携わりたいエンジニアやデザイナーのご応募をお待ちしております！サイトにはまだないですが、インフラエンジニアも近いうちに募集をする事にはなると思います。</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fopen.talentio.com%2F1%2Fc%2Ffeedforce%2Frequisitions%2Fdetail%2F21802\" title=\"Railsエンジニア【Shopify App開発/ID連携サービス】 / 株式会社フィードフォース\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://open.talentio.com/1/c/feedforce/requisitions/detail/21802\">open.talentio.com</a></cite></p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fopen.talentio.com%2F1%2Fc%2Ffeedforce%2Frequisitions%2Fdetail%2F21755\" title=\"フロントエンドエンジニア【Shopifyアプリ開発/ID連携サービス/React/TypeScript】 / 株式会社フィードフォース\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://open.talentio.com/1/c/feedforce/requisitions/detail/21755\">open.talentio.com</a></cite></p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fopen.talentio.com%2F1%2Fc%2Ffeedforce%2Frequisitions%2Fdetail%2F21760\" title=\"UI/UXデザイナー【ID連携サービス/マーケティング支援SaaS】 / 株式会社フィードフォース\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://open.talentio.com/1/c/feedforce/requisitions/detail/21760\">open.talentio.com</a></cite></p>\n\n<p>フィードフォース の他のサービスもエンジニアを募集してますので、興味があればご応募お待ちしております！</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fengineers.recruit.feedforce.jp%2F%3F_ga%3D2.157559610.1029003260.1630297434-1923366822.1626416415%23entry\" title=\"フィードフォース エンジニア・デザイナー採用サイト\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://engineers.recruit.feedforce.jp/?_ga=2.157559610.1029003260.1630297434-1923366822.1626416415#entry\">engineers.recruit.feedforce.jp</a></cite></p>\n","contentSnippet":"ソーシャルPLUS の開発チームでインフラエンジニア をやっています id:mayuki123 です。今月からフィードフォースから分社化をした株式会社ソーシャルPLUS の所属となりましたが、仕事内容は変わらずにサービスのインフラ改善を進めていく事になるかと思います。2019年11月に技術スタックを整理してみたという記事から2年弱経過していますが、ソーシャルPLUSのインフラ環境は、一部アプリケーションについてはコンテナ環境を Amazon EKS にホスティングして本番運用するようになりました。あと数ヶ月ほどで全ての環境がEC2からコンテナに置き換えられると良いなと思っています(願望)。developer.feedforce.jpそして、既に利用されている機能の一部を Amazon EKS に移行して、しばらく経過した時にアプリケーションでネットワークエラーが稀に発生していました。原因調査をした結果が CoreDNS の負荷によるものと発覚するまでのトラブルシュートの流れについて、記事として書き残しておきます。発生していた事象Datadog を活用した原因調査アプリケーションの負荷状況EKS 上のコンテナの調査EKS のCoreDNS の調査CoreDNS のデバッグログの有効化Kubernetes の名前解決についてCoreDNS の負荷軽減ドメインの末尾にドット (.) を追加する/etc/resolv.conf で ndots:1 の設定をするその他の CoreDNS の負荷軽減の方法最終的な結果おわりにおまけ発生していた事象ソーシャルPLUSでは、バックエンドのアプリケーションでエラーが発生した時に、Bugsnag を利用して Slack 通知するようにしています。ある時にMysql2::Error::ConnectionError が発生しました。単発のネットワークエラーの場合はアプリケーションがリトライする事でサービス影響がない事も多く、一時的な問題と思って静観する事があるかと思います。しかし、また数日後に同じ事象が発生しました。ハインリッヒの1：29：300の法則のように、ちょっとした異常を見落としていると重大なサービス障害となってしまう可能性があるので、原因調査を始めます。Datadog を活用した原因調査ソーシャルPLUSでは、モニタリングサービスの Datadog を利用しているのでメトリクスやログの調査を出来るようになっています。どこが原因かを探り始めました。アプリケーションの負荷状況まずはアプリケーションで利用するサーバの負荷状況を確認する所から始めました。Mysql2::Error::ConnectionError が発生した時刻は EKS の Node の CPU 使用率が 70% ほどで、アプリケーションで負荷のかかる処理の最中でした。また、データベースの負荷は少し前に負荷対策の改善をした事もあって、今回の事件の犯人ではなさそうです。他にもEC2 と DB 間でネットワークのボトルネックがないかなどの確認はしましたが、CPU 使用率が高い以外の問題は特に見つかりませんでした。完全犯罪でしょうか。EKS 上のコンテナの調査サーバ単体の問題ではないとすると、Amazon EKS で何か起きている事を疑うことにしました。EKSで動かしているコンテナのログは Datadog Logs に送っているので、エラーが発生していたアプリケーション以外のログ を確認していると、MySQL の ConnectionError が発生した時間帯に下記の Warning のメッセージが出ている事に気づきました。このログは Amazon Kinesis Data Firehose にログを送る Fluent Bit のコンテナで発生しており、エラーが発生してたアプリケーションとは異なるノードに存在してました。[yyyy/mm/dd hh:mm:ss] [ warn] [net] getaddrinfo(host='kinesis.ap-northeast-1.amazonaws.com'): Name or service not known同時刻に特定のアプリケーション以外のコンテナも影響を受けていることから、EKS の中で問題がありそうです。元々、EKSに関する技術ブログは目を通すようにしていた事もあり、Kubernetes の DNS の名前解決で問題が発生する場合があるというのは知っていたので、CoreDNSに焦点を当てて調べることにしました。アウトプットをしてくれる人たちには、いつも感謝をしています。Production Ready EKS CoreDNS Configuration | by Serkan Capkan | Cloutive Technology Solutions - Tech Blog | MediumEKSでDNSを安定させるために対応したこと - Chatwork Creator's Noteスマホゲームの API サーバにおける EKS の運用事例 | エンジニアブログ | GREE EngineeringEKS のCoreDNS の調査Datadog Agent で Kurbernetes の各種メトリクスを収集していて、EKS の CoreDNS の状況も Datadog の Metric Explorer で確認する事が出来るようになっています。Datadog で取得可能な CoreDNS のメトリクスcoredns.request_count を確認すると特定の時間帯で CoreDNS へのリクエストが多い状態で、このタイミングでの CoreDNS Pod の CPU 負荷は10％前後でしたが、それ以外に不審なメトリクスは存在しませんでした。まだ事象の原因との確信は持てないですが、負荷がそれなりにかかっていることは確かなのでリクエストが多くなる理由を調べます。CoreDNS のデバッグログの有効化まずは CoreDNS のデバッグログを確認したいとなるかと思いますが、EKS の CoreDNS はデフォルトだとデバッグログの出力がオフの状態のため、どのようなリクエストが到達しているのかは確認する事ができません。CoreDNS のログを有効化する方法は AWS のナレッジベースにある記事に方法が記載されています。Amazon EKS での DNS 障害のトラブルシューティングこの記事によると、Namespace(kube-system) に Configmap (coredns) があるので、Corefile 設定に log を追加するとデバッグログ が出力されるようになります。# kubectl -n kube-system edit configmap corednskind: ConfigMapapiVersion: v1data:  Corefile: |    .:53 {        log    # Enabling CoreDNS Logging        errors        health        kubernetes cluster.local in-addr.arpa ip6.arpa {          pods insecure          upstream          fallthrough in-addr.arpa ip6.arpa        }        ...上記の設定をすると CoreDNS のPod の標準出力にデバッグログ が出力されるようになります。私の触っていた EKS の環境の場合は、数分ほどで CoreDNS の Pod で reload が発生して元の設定（デバッグログ がオフ）に戻るようになってました。Kubernetes の名前解決について次にKubernetes 上のコンテナはどのように名前解決するのかを知っておく必要があります。Kurbernetes の Pod の DNS リゾルバー(/etc/resolv.conf) のデフォルト設定は下記のようになっています。% kubectl exec fluent-bit-46zvl -- cat /etc/resolv.confnameserver 172.20.0.10search logging.svc.cluster.local svc.cluster.local cluster.localoptions ndots:5この状態で Fluent Bit のコンテナから Amazon Kinesis の API エンドポイントに疎通する場合は、CoreDNS に8回のリクエストが発生します。これは、IPv4 , IPv6 の2種類の名前解決を search の数だけ名前解決を試みた後で EKS 外に名前解決をする設定になっているからです。この設定になっているおかげで Kubernetes の Service を使った名前解決が出来るようになっています。また、options ndots:5 の設定は . の数が 5個以上の時は最初から外部に名前解決するようになります。そのため、Amazon Aurora や ElastiCache などのデータベースへの クラスターエンドポイントは . の数が五個以上あるので、CoreDNSへのリクエスト回数は少なくて済みます。ここを意識しなくてよいのはありがたいですね。ソーシャルPLUSというプロダクトの特性上、EKS 内のアプリケーションから外部サービスの API を実行する機会が多々あります。特定のタイミングで外部のサービスに大量のAPIリクエストを実行した際に、CoreDNS へのリクエストが増大してしまい不安定になってしまったのではと考えられます。CoreDNS の負荷軽減Kurbernetes 上のコンテナの名前解決を知ると、外部サービスのAPI を実行する際には CoreDNS へのリクエストが多くなる事が分かりました。ここで、CoreDNS へのリクエスト数を減らす方法は下記の二つがあります。これも AWS のナレッジベースに方法が記載されているので、詳細は下記の記事を読む方が良いと思います。Amazon EKS での DNS 障害のトラブルシューティングドメインの末尾にドット (.) を追加する接続先のドメインの最後に . をつけると、EKS の内部で名前解決を複数回しないようになり、CoreDNS へのリクエストの総数が減ります。一例をあげると、example.com ではなく、 example.com. とする事で最初から EKS の外部に名前解決をしてくれるようになります。ドメインが SDK の内部で定義されているような場合など、変更出来ない場合はこの方法は利用出来ないかと思います。/etc/resolv.conf で ndots:1 の設定をする/etc/resolv.conf に options ndots:5 とデフォルトで設定されている数値を 1 にする事で、ドメインに . が含まれている場合は常に EKS の外部に名前解決するようになります。Kubernetes の Manifest に spec.dnsConfig パラメータを設定する事で Pod 単位で変更が出来ます。ただし、この設定をすると EKS 内部で名前解決をしなくなってしまいますが、<name>.<namespace>.svc.cluster.local. のように最後に . をつけると名前解決出来ました。Kurbernetes の Service の数が多いとこの方法を周知させるのも大変だと思います。apiVersion: apps/v1kind: Deploymentmetadata:  name: hogespec:  template:    spec:      dnsConfig:        options:          - name: ndots            value: \"1\"その他の CoreDNS の負荷軽減の方法上記の二つの方法は CoreDNS へのリクエスト数を減らすことで、負荷を軽減するようなアプローチでした。CoreDNS の Pod 数はデフォルトで 2個となりますが、CoreDNS のPod をオートスケールする手段もあります。Autoscale the DNS Service in a Clusterまた、Daemonset で DNS キャッシュをノード単位で配置するという方法もあります。KubernetesクラスターでNodeLocal DNSキャッシュを使用するこの辺りは他の方が書いた技術ブログも多くあるかと思うので、この記事では特に説明はしないです。最終的な結果ソーシャルPLUSでは最終的に根本原因の CoreDNS へのリクエスト数を減らすために /etc/resolv.conf で ndots:1 の設定をするようにしました。この設定をアプリケーションの Pod に適応した所、CoreDNS へのリクエスト数は 25% ほどと目に見えて減少させる事が出来ました。キャプチャは載せてないですが、CoreDNS の Pod の CPU使用率も 以前の半分ほどになったので、負荷軽減の目的は達成しました。ここまで、確信を持てないまま CoreDNS の負荷軽減に取り組みましたが、元々のネットワークエラーであった Mysql2::Error::ConnectionError のエラーは再発しなくなりました。また、EKS 上の他のコンテナも Name or service not known のような名前解決が出来ないといったエラーも発生しなくなりました。CoreDNS の負荷を減らす事で悩まされていた問題の解消が出来たと思います。今回のように比較的早い段階で気づく事が出来たので、お客さんへのサービス影響のある問題に発展せずに済みました。今後、利用者数が増えてより負荷のかかる状況になってきた時には再発する可能性はありますが、早い段階で気付けるように日々確認するダッシュボードにメトリクスを追加するようにしています。その時がきた場合は CoreDNS の Pod 数の調整や DNS キャッシュの導入が必要になりそうです。おわりに最終的には Pod の DNS 設定を調整するだけでネットワークエラーは解決しました。この記事では、結果だけではなくて解決に至るまでの経緯をメインにまとめてみました。実施していて良かったと思うことを下記にまとめます。これらの事が出来ていなければ、今回のようなネットワークエラーはたまに発生する事象として、根本原因の追及は出来なかったと思うので、サービスのオブザーバビリティを整備する事や日々の情報収集は大事ですね。アプリケーションのエラーを Slack に通知していたKurbernetes のメトリクスを Datadog で確認できる状態だったコンテナのログを一元的に Datadog Logs  で閲覧できるようにしていた他の人の技術ブログから Kubernetes の CoreDNS が不安定になることを知っていたこの記事に間違っている内容や、もっと良い改善方法がある事をご存知の方がいましたら、優しく教えてください。おまけ現在、ソーシャルPLUS では作りたい機能が山ほどある状況でまだまだ成長するサービスになると思うので、成長を続けるサービスに携わりたいエンジニアやデザイナーのご応募をお待ちしております！サイトにはまだないですが、インフラエンジニアも近いうちに募集をする事にはなると思います。open.talentio.comopen.talentio.comopen.talentio.comフィードフォース の他のサービスもエンジニアを募集してますので、興味があればご応募お待ちしております！engineers.recruit.feedforce.jp","link":"https://developer.feedforce.jp/entry/2021/09/02/134725","isoDate":"2021-09-02T04:47:25.000Z","dateMiliSeconds":1630558045000,"imageUrl":"https://cdn.user.blog.st-hatena.com/default_entry_og_image/4268819/1588226000876991","authorName":"feedforce"},{"title":"Firestore エミュレーターを使ったテスト同士の競合が起きないようにしていい感じにテストできるようにした話","content":"<p>こんにちは、エンジニアの <a href=\"http://blog.hatena.ne.jp/len_prog/\" class=\"hatena-id-icon\"><img src=\"https://cdn.profile-image.st-hatena.com/users/len_prog/profile.png\" width=\"16\" height=\"16\" alt=\"\" class=\"hatena-id-icon\">id:len_prog</a> です。</p>\n\n<p>私が所属している <a href=\"https://ecbooster.jp/\">EC Booster</a> チームでは、「<a href=\"https://support.ecbooster.jp/ja/articles/4854572-%E3%82%AB%E3%82%A4%E3%82%BC%E3%83%B3%E3%82%AB%E3%83%BC%E3%83%89%E3%81%AE%E6%A6%82%E8%A6%81%E3%81%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">カイゼンカード</a>」機能の開発に Firebase を採用しています。<br />\nその中でも特に Cloud Functions for Firebase と Cloud Firestore をメインで使用しており、これらの採用により短い開発期間で機能をリリースすることができました 🎉</p>\n\n<p>しかし、Firebase を採用したことで苦労したことが全く無かったわけではありません。<br />\n特に、テスト周りはインターネット上にもあまり情報が多くない状況で、色々ハマりながら開発をしてきました。</p>\n\n<p>そこで、今回の記事では、いくつかあったハマりごとの中でも特に厄介だったものについて対策を書いていきます。</p>\n\n<h1>Firestore Emulator のプロジェクト共有時のデータ競合</h1>\n\n<p><a href=\"https://firebase.google.com/docs/emulator-suite?hl=ja\">Firebase Local Emulator Suite</a> を使って Firestore に接続するテストを書いていた際に、<br />\nテストを単体で実行した場合には通るのに、他のテストと並列に実行した場合のみドキュメントの状態が予期せぬものになりテストが落ちてしまうことに悩まされました。</p>\n\n<p>調査の結果、これは、接続先プロジェクトがすべてのテストで同じになってしまっているのが原因ということが分かりました。</p>\n\n<p>この状態で同じドキュメントを書き換えるテストが並列で走ってしまった場合、実行タイミングによってはドキュメントが予期せぬ状態になってしまいます。<br />\nまた、テスト結果が不安定だとテストが信用できず、実装を保証するものになりません。</p>\n\n<p>このままでは役に立つテストが書けないと思い試行錯誤した結果、<strong>テストごとに違うプロジェクトの Firestore に接続する</strong>ことでそれぞれのテストが独立した状態で実行でき、結果としてデータ競合が防げることが分かりました。</p>\n\n<p>以下、サンプルアプリケーションを用いてこの方法について書いていきます。</p>\n\n<h1>サンプルアプリケーションの概要</h1>\n\n<p>今回は、サンプルとして簡易的な RPG を開発することを想定します。<br />\nゲームに登場するキャラクターは、以下のような構造のドキュメントを持つ <code>characters</code> コレクションで管理されています。</p>\n\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synIdentifier\">{</span>\n  name: <span class=\"synType\">string</span><span class=\"synStatement\">;</span>\n  level: <span class=\"synType\">number</span><span class=\"synStatement\">;</span>\n  job: <span class=\"synType\">string</span><span class=\"synStatement\">;</span>\n<span class=\"synIdentifier\">}</span>\n</pre>\n\n\n<p>また、このゲームでは以下の行動のみが可能と仮定します(これだけじゃゲームとして成り立たないと思いますが、簡単のためということでお許しください)</p>\n\n<ul>\n<li>キャラクターは、レベルアップすることができる</li>\n<li>キャラクターは、転職することができる\n\n<ul>\n<li>転職すると、キャラクターのレベルが1に戻る</li>\n</ul>\n</li>\n</ul>\n\n\n<p>なお、アプリケーション上においてキャラクターのレベルアップは、<code>characterLevelUpUseCase</code>、キャラクターの転職は <code>characterJobChangeUseCase</code> という関数を呼ぶことで行えることとします。</p>\n\n<p>ここからは、実際にこれら2つの関数のテストコードが競合する様子を見ていきます。</p>\n\n<h1>データ競合発生時の構成</h1>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/l/len_prog/20210624/20210624165133.png\" alt=\"f:id:len_prog:20210624165133p:plain:w500\" width=\"1200\" height=\"790\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" style=\"width:500px\" itemprop=\"image\"></span></p>\n\n<p><code>characterJobChangeUseCase</code> と <code>characterLevelUpUseCase</code> が <code>my-game</code> プロジェクトの Firestore を共有してしまっています。<br />\nこの状態で両方の関数から同じドキュメントを書き換えてしまった場合、データ競合が発生する可能性があります。<br />\nこの場合、実際のコードは以下のようになります。</p>\n\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synComment\">// functions/src/usecases/characterJobChangeUseCase.spec.ts</span>\n<span class=\"synStatement\">import</span> * <span class=\"synStatement\">as</span> admin <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;firebase-admin&quot;</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> characterJobChangeUseCase <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@/usecases/characterJobChangeUseCase&quot;</span><span class=\"synStatement\">;</span>\n\nadmin.initializeApp<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n  projectId: <span class=\"synConstant\">&quot;my-game&quot;</span><span class=\"synStatement\">,</span> <span class=\"synComment\">// ここが問題</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synStatement\">const</span> charactersCollection <span class=\"synStatement\">=</span> admin\n  .firestore<span class=\"synStatement\">()</span>\n  .collection<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;characters&quot;</span><span class=\"synStatement\">);</span>\n\ndescribe<span class=\"synStatement\">(</span>characterJobChangeUseCase<span class=\"synStatement\">,</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> targetCharacterId <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;target-character-id&quot;</span><span class=\"synStatement\">;</span>\n\n  beforeEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.set<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n        name: <span class=\"synConstant\">&quot;アルス&quot;</span><span class=\"synStatement\">,</span>\n        level: <span class=\"synConstant\">10</span><span class=\"synStatement\">,</span>\n        job: <span class=\"synConstant\">&quot;すっぴん&quot;</span><span class=\"synStatement\">;</span>\n    <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  afterEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.<span class=\"synStatement\">delete();</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  it<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;キャラクターが転職した場合、レベルが1に戻ること&quot;</span><span class=\"synStatement\">,</span> <span class=\"synStatement\">async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> characterJobChangeUseCase<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">);</span> <span class=\"synComment\">// characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1に戻る</span>\n    <span class=\"synStatement\">const</span> jobChangedCharacter <span class=\"synStatement\">=</span> <span class=\"synStatement\">(await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.get<span class=\"synStatement\">())</span>.data<span class=\"synStatement\">();</span>\n\n    expect<span class=\"synStatement\">(</span>jobChangedCharacter.level<span class=\"synStatement\">)</span>.toBe<span class=\"synStatement\">(</span><span class=\"synConstant\">1</span><span class=\"synStatement\">);</span> <span class=\"synComment\">// 実行タイミング次第では、1になるはずが11になってしまう！</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre>\n\n\n\n\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synComment\">// functions/src/usecases/characterLevelUpUseCase.spec.ts</span>\n<span class=\"synStatement\">import</span> * <span class=\"synStatement\">as</span> admin <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;firebase-admin&quot;</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> characterLevelUpUseCase <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@/usecases/characterLevelUpUseCase&quot;</span><span class=\"synStatement\">;</span>\n\nadmin.initializeApp<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n  projectId: <span class=\"synConstant\">&quot;my-game&quot;</span><span class=\"synStatement\">,</span> <span class=\"synComment\">// ここが問題</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synStatement\">const</span> charactersCollection <span class=\"synStatement\">=</span> admin\n  .firestore<span class=\"synStatement\">()</span>\n  .collection<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;characters&quot;</span><span class=\"synStatement\">);</span>\n\ndescribe<span class=\"synStatement\">(</span>characterLevelUpUseCase<span class=\"synStatement\">,</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> targetCharacterId <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;target-character-id&quot;</span><span class=\"synStatement\">;</span>\n\n  beforeEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.set<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n        name: <span class=\"synConstant\">&quot;アルス&quot;</span><span class=\"synStatement\">,</span>\n        level: <span class=\"synConstant\">10</span><span class=\"synStatement\">,</span>\n        job: <span class=\"synConstant\">&quot;すっぴん&quot;</span><span class=\"synStatement\">;</span>\n    <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  afterEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.<span class=\"synStatement\">delete();</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  it<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;キャラクターがレベルアップした場合、レベルが1上がること&quot;</span><span class=\"synStatement\">,</span> <span class=\"synStatement\">async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> characterLevelUpUseCase<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">);</span> <span class=\"synComment\">// characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1上がる</span>\n    <span class=\"synStatement\">const</span> grownCharacter <span class=\"synStatement\">=</span> <span class=\"synStatement\">(await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.get<span class=\"synStatement\">())</span>.data<span class=\"synStatement\">();</span>\n\n    expect<span class=\"synStatement\">(</span>grownCharacter.level<span class=\"synStatement\">)</span>.toBe<span class=\"synStatement\">(</span><span class=\"synConstant\">11</span><span class=\"synStatement\">);</span> <span class=\"synComment\">// 実行タイミング次第では、11になるはずが1に戻ってしまう！</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre>\n\n\n<p>見ての通り、両方のテストが <code>my-game</code> プロジェクトの Firestore の、ID: <code>target-character-id</code> のドキュメントを更新してしまっています。<br />\nこれらのテストコードを並列で実行した場合、<strong>キャラクターが転職したのにレベルが1に戻らない</strong>、<strong>キャラクターがレベルアップしたはずなのになぜかレベル1に戻ってしまう</strong>など予期せぬ状態になってしまい、\nテストが落ちてしまう可能性があります。</p>\n\n<p>この状態ではテストコードが信用できないので、テストごとに向き先プロジェクトを変えてこの問題を解決していきます。</p>\n\n<h1>データ競合解決後の構成</h1>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/l/len_prog/20210705/20210705113933.png\" alt=\"f:id:len_prog:20210705113933p:plain:w500\" width=\"1200\" height=\"779\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" style=\"width:500px\" itemprop=\"image\"></span></p>\n\n<p>上図②③のようにテストごとに接続先プロジェクトを独立させることで、他のテストとの並列実行が原因のデータ競合を防ぐことができます。<br />\n具体的には、以下のように <code>admin.initializeApp()</code>の第一引数に他のテストと重複しないプロジェクトID を渡すようにします。</p>\n\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synComment\">// functions/src/usecases/characterJobChangeUseCase.spec.ts</span>\n\nadmin.initializeApp<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n  projectId: <span class=\"synConstant\">&quot;character-job-change-use-case-spec&quot;</span><span class=\"synStatement\">,</span> <span class=\"synComment\">//  図の②に対応</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// functions/src/usecases/characterLevelUpUseCase.spec.ts</span>\n\nadmin.initializeApp<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n  projectId: <span class=\"synConstant\">&quot;character-level-up-use-case-spec&quot;</span><span class=\"synStatement\">,</span> <span class=\"synComment\">// 図の③に対応</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre>\n\n\n<p>変更後のコードの全体像は以下のようになります。</p>\n\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synComment\">// functions/src/usecases/characterJobChangeUseCase.spec.ts</span>\n<span class=\"synStatement\">import</span> * <span class=\"synStatement\">as</span> admin <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;firebase-admin&quot;</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> characterJobChangeUseCase <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@/usecases/characterJobChangeUseCase&quot;</span><span class=\"synStatement\">;</span>\n\nadmin.initializeApp<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n  projectId: <span class=\"synConstant\">&quot;character-job-change-use-case-spec&quot;</span><span class=\"synStatement\">,</span> <span class=\"synComment\">//  図の②に対応</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// ここから下は構成変更前のコードと同じ</span>\n\n<span class=\"synStatement\">const</span> charactersCollection <span class=\"synStatement\">=</span> admin\n  .firestore<span class=\"synStatement\">()</span>\n  .collection<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;characters&quot;</span><span class=\"synStatement\">);</span>\n\ndescribe<span class=\"synStatement\">(</span>characterJobChangeUseCase<span class=\"synStatement\">,</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> targetCharacterId <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;target-character-id&quot;</span><span class=\"synStatement\">;</span>\n\n  beforeEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.set<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n        name: <span class=\"synConstant\">&quot;アルス&quot;</span><span class=\"synStatement\">,</span>\n        level: <span class=\"synConstant\">10</span><span class=\"synStatement\">,</span>\n        job: <span class=\"synConstant\">&quot;すっぴん&quot;</span><span class=\"synStatement\">;</span>\n    <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  afterEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.<span class=\"synStatement\">delete();</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  it<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;キャラクターが転職した場合、レベルが1に戻ること&quot;</span><span class=\"synStatement\">,</span> <span class=\"synStatement\">async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> characterJobChangeUseCase<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">);</span> <span class=\"synComment\">// characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1に戻る</span>\n    <span class=\"synStatement\">const</span> jobChangedCharacter <span class=\"synStatement\">=</span> <span class=\"synStatement\">(await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.get<span class=\"synStatement\">())</span>.data<span class=\"synStatement\">();</span>\n\n    expect<span class=\"synStatement\">(</span>jobChangedCharacter.level<span class=\"synStatement\">)</span>.toBe<span class=\"synStatement\">(</span><span class=\"synConstant\">1</span><span class=\"synStatement\">);</span> <span class=\"synComment\">// 転職するとレベルが1に戻ることを検証できるようになった</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre>\n\n\n\n\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synComment\">// functions/src/usecases/characterLevelUpUseCase.spec.ts</span>\n<span class=\"synStatement\">import</span> * <span class=\"synStatement\">as</span> admin <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;firebase-admin&quot;</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> characterLevelUpUseCase <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@/usecases/characterLevelUpUseCase&quot;</span><span class=\"synStatement\">;</span>\n\nadmin.initializeApp<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n  projectId: <span class=\"synConstant\">&quot;character-level-up-use-case-spec&quot;</span><span class=\"synStatement\">,</span> <span class=\"synComment\">// 図の③に対応</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// ここから下は構成変更前のコードと同じ</span>\n\n<span class=\"synStatement\">const</span> charactersCollection <span class=\"synStatement\">=</span> admin\n  .firestore<span class=\"synStatement\">()</span>\n  .collection<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;characters&quot;</span><span class=\"synStatement\">);</span>\n\ndescribe<span class=\"synStatement\">(</span>characterLevelUpUseCase<span class=\"synStatement\">,</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> targetCharacterId <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;target-character-id&quot;</span><span class=\"synStatement\">;</span>\n\n  beforeEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.set<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span>\n        name: <span class=\"synConstant\">&quot;アルス&quot;</span><span class=\"synStatement\">,</span>\n        level: <span class=\"synConstant\">10</span><span class=\"synStatement\">,</span>\n        job: <span class=\"synConstant\">&quot;すっぴん&quot;</span><span class=\"synStatement\">;</span>\n    <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  afterEach<span class=\"synStatement\">(async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.<span class=\"synStatement\">delete();</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  it<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;キャラクターがレベルアップした場合、レベルが1上がること&quot;</span><span class=\"synStatement\">,</span> <span class=\"synStatement\">async</span> <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">await</span> characterLevelUpUseCase<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">);</span> <span class=\"synComment\">// characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1上がる</span>\n    <span class=\"synStatement\">const</span> grownCharacter <span class=\"synStatement\">=</span> <span class=\"synStatement\">(await</span> charactersCollection.doc<span class=\"synStatement\">(</span>targetCharacterId<span class=\"synStatement\">)</span>.get<span class=\"synStatement\">())</span>.data<span class=\"synStatement\">();</span>\n\n    expect<span class=\"synStatement\">(</span>grownCharacter.level<span class=\"synStatement\">)</span>.toBe<span class=\"synStatement\">(</span><span class=\"synConstant\">11</span><span class=\"synStatement\">);</span> <span class=\"synComment\">// レベルアップした場合にレベルが1上がることを検証できるようになった</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre>\n\n\n<p>このようにテストごとに向き先プロジェクトを変えることで、それぞれのテストで担保したいことをちゃんと担保できるようになります。</p>\n\n<h1>ちょっと微妙な点</h1>\n\n<p>上記の方法でテストごとに独立した環境の Firestore を操作できるようになり、データ競合を防げるようになりました。</p>\n\n<p>しかし、この方法にはひとつだけ微妙な点があります。<br />\n問題の説明のために、先程掲載した<code>競合解決後の構成図</code>を再掲します。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/l/len_prog/20210705/20210705113933.png\" alt=\"f:id:len_prog:20210705113933p:plain:w500\" width=\"1200\" height=\"779\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" style=\"width:500px\" itemprop=\"image\"></span></p>\n\n<p>上図①の接続先は、<code>$ firebase use</code> で指定したプロジェクトか、<code>$ firebase emulators:start</code> に <code>--project</code>を渡した場合にはそのプロジェクトになり、そのほかの方法で変えることは今のところできないようです。</p>\n\n<p>そのため、プロジェクトをテストごとに分けた場合、上図②③のテスト中にテスト自体は動くものの、Firebase Emulator の UI からデータの内容を見ることはできなくなります。</p>\n\n<p>一応、接続先を <code>$ firebase use</code> で指定しているものに切り替えるようコードを書き換えたりすればデバッグはできますが、\nいちいち書き換えの手間が生じるので若干面倒です。</p>\n\n<p>また、これは Firebase Enulator の UI で立ち上がっているすべてのプロジェクトの Firestore を見られるようになれば解決する問題ではあり、実際に <a href=\"https://github.com/firebase/firebase-tools-ui\">firebase/firebase-tools-ui</a> リポジトリに <a href=\"https://github.com/firebase/firebase-tools-ui/issues/281\">issue</a> も立っていますが、すぐに対応が終わりそうには見えない状況なので、しばらくは不便な状況が続くことが予想されます。</p>\n\n<h1>所感</h1>\n\n<p>Firebase は便利ですが、当然ながら全くハマらずに開発できる銀の弾丸ではないですね。<br />\nしかし、基本的には便利でドキュメントもそれなりに読みやすく、個人的には使っていて満足感があります。</p>\n\n<p>今後も日々の開発で得た Firebase や GCP 周りの TIPS を書いていけたらと思っておりますので、よろしくお願いいたします 🙏</p>\n","contentSnippet":"こんにちは、エンジニアの id:len_prog です。私が所属している EC Booster チームでは、「カイゼンカード」機能の開発に Firebase を採用しています。しかし、Firebase を採用したことで苦労したことが全く無かったわけではありません。そこで、今回の記事では、いくつかあったハマりごとの中でも特に厄介だったものについて対策を書いていきます。Firestore Emulator のプロジェクト共有時のデータ競合Firebase Local Emulator Suite を使って Firestore に接続するテストを書いていた際に、調査の結果、これは、接続先プロジェクトがすべてのテストで同じになってしまっているのが原因ということが分かりました。この状態で同じドキュメントを書き換えるテストが並列で走ってしまった場合、実行タイミングによってはドキュメントが予期せぬ状態になってしまいます。このままでは役に立つテストが書けないと思い試行錯誤した結果、テストごとに違うプロジェクトの Firestore に接続することでそれぞれのテストが独立した状態で実行でき、結果としてデータ競合が防げることが分かりました。以下、サンプルアプリケーションを用いてこの方法について書いていきます。サンプルアプリケーションの概要今回は、サンプルとして簡易的な RPG を開発することを想定します。characters コレクションで管理されています。{  name: string;  level: number;  job: string;}また、このゲームでは以下の行動のみが可能と仮定します(これだけじゃゲームとして成り立たないと思いますが、簡単のためということでお許しください)キャラクターは、レベルアップすることができるキャラクターは、転職することができる転職すると、キャラクターのレベルが1に戻るなお、アプリケーション上においてキャラクターのレベルアップは、characterLevelUpUseCase、キャラクターの転職は characterJobChangeUseCase という関数を呼ぶことで行えることとします。ここからは、実際にこれら2つの関数のテストコードが競合する様子を見ていきます。データ競合発生時の構成characterJobChangeUseCase と characterLevelUpUseCase が my-game プロジェクトの Firestore を共有してしまっています。// functions/src/usecases/characterJobChangeUseCase.spec.tsimport * as admin from \"firebase-admin\";import { characterJobChangeUseCase } from \"@/usecases/characterJobChangeUseCase\";admin.initializeApp({  projectId: \"my-game\", // ここが問題});const charactersCollection = admin  .firestore()  .collection(\"characters\");describe(characterJobChangeUseCase, () => {  const targetCharacterId = \"target-character-id\";  beforeEach(async () => {    await charactersCollection.doc(targetCharacterId).set({        name: \"アルス\",        level: 10,        job: \"すっぴん\";    });  });  afterEach(async () => {    await charactersCollection.doc(targetCharacterId).delete();  });  it(\"キャラクターが転職した場合、レベルが1に戻ること\", async () => {    await characterJobChangeUseCase(targetCharacterId); // characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1に戻る    const jobChangedCharacter = (await charactersCollection.doc(targetCharacterId).get()).data();    expect(jobChangedCharacter.level).toBe(1); // 実行タイミング次第では、1になるはずが11になってしまう！  });});// functions/src/usecases/characterLevelUpUseCase.spec.tsimport * as admin from \"firebase-admin\";import { characterLevelUpUseCase } from \"@/usecases/characterLevelUpUseCase\";admin.initializeApp({  projectId: \"my-game\", // ここが問題});const charactersCollection = admin  .firestore()  .collection(\"characters\");describe(characterLevelUpUseCase, () => {  const targetCharacterId = \"target-character-id\";  beforeEach(async () => {    await charactersCollection.doc(targetCharacterId).set({        name: \"アルス\",        level: 10,        job: \"すっぴん\";    });  });  afterEach(async () => {    await charactersCollection.doc(targetCharacterId).delete();  });  it(\"キャラクターがレベルアップした場合、レベルが1上がること\", async () => {    await characterLevelUpUseCase(targetCharacterId); // characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1上がる    const grownCharacter = (await charactersCollection.doc(targetCharacterId).get()).data();    expect(grownCharacter.level).toBe(11); // 実行タイミング次第では、11になるはずが1に戻ってしまう！  });});見ての通り、両方のテストが my-game プロジェクトの Firestore の、ID: target-character-id のドキュメントを更新してしまっています。キャラクターが転職したのにレベルが1に戻らない、キャラクターがレベルアップしたはずなのになぜかレベル1に戻ってしまうなど予期せぬ状態になってしまい、テストが落ちてしまう可能性があります。この状態ではテストコードが信用できないので、テストごとに向き先プロジェクトを変えてこの問題を解決していきます。データ競合解決後の構成上図②③のようにテストごとに接続先プロジェクトを独立させることで、他のテストとの並列実行が原因のデータ競合を防ぐことができます。admin.initializeApp()の第一引数に他のテストと重複しないプロジェクトID を渡すようにします。// functions/src/usecases/characterJobChangeUseCase.spec.tsadmin.initializeApp({  projectId: \"character-job-change-use-case-spec\", //  図の②に対応});// functions/src/usecases/characterLevelUpUseCase.spec.tsadmin.initializeApp({  projectId: \"character-level-up-use-case-spec\", // 図の③に対応});変更後のコードの全体像は以下のようになります。// functions/src/usecases/characterJobChangeUseCase.spec.tsimport * as admin from \"firebase-admin\";import { characterJobChangeUseCase } from \"@/usecases/characterJobChangeUseCase\";admin.initializeApp({  projectId: \"character-job-change-use-case-spec\", //  図の②に対応});// ここから下は構成変更前のコードと同じconst charactersCollection = admin  .firestore()  .collection(\"characters\");describe(characterJobChangeUseCase, () => {  const targetCharacterId = \"target-character-id\";  beforeEach(async () => {    await charactersCollection.doc(targetCharacterId).set({        name: \"アルス\",        level: 10,        job: \"すっぴん\";    });  });  afterEach(async () => {    await charactersCollection.doc(targetCharacterId).delete();  });  it(\"キャラクターが転職した場合、レベルが1に戻ること\", async () => {    await characterJobChangeUseCase(targetCharacterId); // characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1に戻る    const jobChangedCharacter = (await charactersCollection.doc(targetCharacterId).get()).data();    expect(jobChangedCharacter.level).toBe(1); // 転職するとレベルが1に戻ることを検証できるようになった  });});// functions/src/usecases/characterLevelUpUseCase.spec.tsimport * as admin from \"firebase-admin\";import { characterLevelUpUseCase } from \"@/usecases/characterLevelUpUseCase\";admin.initializeApp({  projectId: \"character-level-up-use-case-spec\", // 図の③に対応});// ここから下は構成変更前のコードと同じconst charactersCollection = admin  .firestore()  .collection(\"characters\");describe(characterLevelUpUseCase, () => {  const targetCharacterId = \"target-character-id\";  beforeEach(async () => {    await charactersCollection.doc(targetCharacterId).set({        name: \"アルス\",        level: 10,        job: \"すっぴん\";    });  });  afterEach(async () => {    await charactersCollection.doc(targetCharacterId).delete();  });  it(\"キャラクターがレベルアップした場合、レベルが1上がること\", async () => {    await characterLevelUpUseCase(targetCharacterId); // characterJobChangeUsecase#handle に渡された引数の ID を持つユーザーのレベルが1上がる    const grownCharacter = (await charactersCollection.doc(targetCharacterId).get()).data();    expect(grownCharacter.level).toBe(11); // レベルアップした場合にレベルが1上がることを検証できるようになった  });});このようにテストごとに向き先プロジェクトを変えることで、それぞれのテストで担保したいことをちゃんと担保できるようになります。ちょっと微妙な点上記の方法でテストごとに独立した環境の Firestore を操作できるようになり、データ競合を防げるようになりました。しかし、この方法にはひとつだけ微妙な点があります。競合解決後の構成図を再掲します。上図①の接続先は、$ firebase use で指定したプロジェクトか、$ firebase emulators:start に --projectを渡した場合にはそのプロジェクトになり、そのほかの方法で変えることは今のところできないようです。そのため、プロジェクトをテストごとに分けた場合、上図②③のテスト中にテスト自体は動くものの、Firebase Emulator の UI からデータの内容を見ることはできなくなります。一応、接続先を $ firebase use で指定しているものに切り替えるようコードを書き換えたりすればデバッグはできますが、いちいち書き換えの手間が生じるので若干面倒です。また、これは Firebase Enulator の UI で立ち上がっているすべてのプロジェクトの Firestore を見られるようになれば解決する問題ではあり、実際に firebase/firebase-tools-ui リポジトリに issue も立っていますが、すぐに対応が終わりそうには見えない状況なので、しばらくは不便な状況が続くことが予想されます。所感Firebase は便利ですが、当然ながら全くハマらずに開発できる銀の弾丸ではないですね。今後も日々の開発で得た Firebase や GCP 周りの TIPS を書いていけたらと思っておりますので、よろしくお願いいたします 🙏","link":"https://developer.feedforce.jp/entry/2021/07/07/103917","isoDate":"2021-07-07T01:39:17.000Z","dateMiliSeconds":1625621957000,"imageUrl":"https://cdn-ak.f.st-hatena.com/images/fotolife/l/len_prog/20210705/20210705113933.png","authorName":"feedforce"},{"title":"【2021年夏】半期に1度の Engineer’s Principles Award 受賞者を紹介します","content":"<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/f/feedforce_recruit/20210611/20210611163915.jpg\" alt=\"f:id:feedforce_recruit:20210611163915j:plain\" width=\"1200\" height=\"700\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>こんにちは。人事の今岡と申します。\n2021年もあっという間に6月ですね。</p>\n\n<p>フィードフォースでは先日オンライン納会が開催され、半期に一度の「Engineer’s Principles Award 2021 Summer」の受賞者が発表されました。\n今回アワードを受賞した開発メンバーと表彰内容をご紹介します。</p>\n\n<p>前回の表彰者紹介はコチラ</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fdeveloper.feedforce.jp%2Fentry%2F2020%2F12%2F28%2F131042\" title=\"半期に1度の Engineer’s Principles Award 受賞者を紹介します - Feedforce Developer Blog\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://developer.feedforce.jp/entry/2020/12/28/131042\">developer.feedforce.jp</a></cite></p>\n\n<h2>Engineer’s Principles Award とは</h2>\n\n<p>Engineer’s Principles とは、フィードフォースの開発メンバー向けに現場が主体となって設定した、5つの行動指針です。\n半期に一度、開発メンバー同士で投票を行い、行動指針の項目ごとに最も体現しているメンバーが選ばれ表彰されます。</p>\n\n<p>Engineer’s Principles についてはこちら</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fmedia.feedforce.jp%2Fn%2Fnd1f2236470b3\" title=\"フィードフォースが目指すエンジニア像とは。「Engineer’s Principles」を紹介します｜フィードフォースのnote\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://media.feedforce.jp/n/nd1f2236470b3\">media.feedforce.jp</a></cite></p>\n\n<h2>受賞者紹介</h2>\n\n<p>※表彰コメントは本来社内向けのものであるため一部変更させていただいています。受賞者によって各種アカウントを載せています。</p>\n\n<h3>🏆「Stay Humble; 常に謙虚であるべし」受賞者</h3>\n\n<h4>@len_prog さん</h4>\n\n<p>表彰コメント：<br />\n社内でメジャーな Rails 以外でバックエンドを実装する際に、なぜそうするのかという理由やレイヤーの切り方を他のメンバーにわかりやすく説明していました。\n一方、自分自身で苦手なことがあった場合に、他の人に相談したり、フィードバックを求めそれを受け入れる姿勢は、まさに Stay Humble だと思いました。</p>\n\n<p><i class=\"blogicon-twitter\"></i> <a href=\"https://twitter.com/len_prog\">Len (@len_prog)</a> , <i class=\"blogicon-entry\"></i> <a href=\"https://len-prog.hatenablog.com/\">Blog</a></p>\n\n<h4>@katsunn さん</h4>\n\n<p>表彰コメント：<br />\n事前に色々なアイデアを用意しつつも、相談の過程でお互いの認識や意図を踏まえたうえで改善を進めていく一方、ただ受け入れるだけではなく、\nプロフェッショナルとして自分なりに咀嚼したアウトプットにしていく姿勢が非常に素晴らしく、ベンチマークにすべきだと感じました。</p>\n\n<p><i class=\"blogicon-twitter\"></i>  <a href=\"https://twitter.com/nomo_017\">のもち(@nomo_017)</a></p>\n\n<h3>🏆「Be Positive &amp; Proactive; 常に肯定的・主体的であるべし」受賞者</h3>\n\n<h4>@sukechannnn さん</h4>\n\n<p>表彰コメント：<br />\nエンジニアとして様々なチームビルディングや開発手法を試しているだけではなく、ビジネス視点からも方向性を考え、\nプロダクトオーナーとしてプロダクトを成長させようとしている姿勢は、まさにこの言葉にぴったりだと思います。</p>\n\n<p><i class=\"blogicon-twitter\"></i> <a href=\"https://twitter.com/sukechannnn\"> sukechannnn (@sukechannnn)</a> , <i class=\"fa fa-github\" aria-hidden=\"true\"></i> <a href=\"https://github.com/sukechannnn\">sukechannnn</a></p>\n\n<h4>@daido1976 さん</h4>\n\n<p>表彰コメント：<br />\n分野を問わず新しいことに前向きに挑戦し、気になったことはどんどん質問するのに加え、\n育休中のメンバーに代わって、率先してチームを引っ張っている行動力が素晴らしいと思いました。</p>\n\n<p><i class=\"blogicon-twitter\"></i>  <a href=\"https://twitter.com/daido1976\">Daido Shota (@daido1976)</a> , <i class=\"fa fa-github\" aria-hidden=\"true\"></i>  <a href=\"https://github.com/daido1976\"> daido1976</a></p>\n\n<h3>🏆「Be Prepared; 常に来たるべき機会に備えるべし」受賞者</h3>\n\n<h4>@daido1976 さん</h4>\n\n<p>表彰コメント：<br />\n自分のキャリアや目指すべき方向を踏まえつつ、常にアンテナを立てて知識を広く持とうとしている姿勢がよいと感じています。\nさらに、そうして蓄積したスキルを開発だけではなく、自ら手を挙げ講師をつとめた新卒向け Web 研修にも活かしている点がまさに Be Prepared だと思いました。</p>\n\n<p><i class=\"blogicon-twitter\"></i>  <a href=\"https://twitter.com/daido1976\">Daido Shota (@daido1976)</a> , <i class=\"fa fa-github\" aria-hidden=\"true\"></i>  <a href=\"https://github.com/daido1976\"> daido1976</a></p>\n\n<h4>@namikingsoft さん</h4>\n\n<p>表彰コメント：<br />\nOmni Hub の開発において、あまり開発経験がなかったはずの Rust を使いこなしつつ WAF を含めたインフラ構築をしていて、\n@namikingsoft さんの強みが発揮される局面でした。また dfplus.io でもパフォーマンス改善でコアな知識を活かすなど、まさにこれまでの準備の賜物だと思います。</p>\n\n<p><i class=\"fa fa-github\" aria-hidden=\"true\"></i> <a href=\"https://github.com/namikingsoft\">namikingsoft</a></p>\n\n<h3>🏆「Share All; 己の知見、試行、失敗、遍く共有すべし」受賞者</h3>\n\n<h4>@masutaka さん</h4>\n\n<p>表彰コメント：<br />\nLooker 導入において知見や失敗など社内共有しているほか、そもそも  esa にどう記録すべきかといった、「共有のための知見の共有」にまで配慮しています。\nSlack や esa 、Blog への共有はエンジニアのみならず、全社的にプラスの影響を与えていて、まさに共有の神様と言えるでしょう。</p>\n\n<p><i class=\"blogicon-twitter\"></i> <a href=\"https://twitter.com/masutaka\">Takashi Masuda (@masutaka)</a> , <i class=\"fa fa-github\" aria-hidden=\"true\"></i> <a href=\"https://github.com/masutaka\">masutaka</a> , <i class=\"blogicon-entry\"></i> <a href=\"https://masutaka.net/\">Blog</a></p>\n\n<h4>@kogai さん</h4>\n\n<p>表彰コメント：<br />\nShopify 周りでは、社内だけでなく社外に対してのプレゼンスを示しています。また Omni Hub の開発で多忙な中、\n社内勉強会 Rust の会では実際の新規事業のプロダクトコードを題材に実践的な知見を共有するなど、その共有力はフィードフォースエンジニアの鑑（かがみ）だと思います。</p>\n\n<p><i class=\"blogicon-twitter\"></i> <a href=\"https://twitter.com/iamchawan\">茶碗 (@iamchawan)</a> ,<i class=\"fa fa-github\" aria-hidden=\"true\"></i> <a href=\"https://github.com/kogai\">kogai</a> , <i class=\"blogicon-entry\"></i> <a href=\"https://k9bookshelf.com/blogs/development\">Blog</a></p>\n\n<h3>🏆「Just Do It; 全力でやりきるべし」受賞者</h3>\n\n<h4>@namikingsoftさん</h4>\n\n<p>表彰コメント：<br />\nOmni  Hub リリースまでの道筋をきちんと立ててスケジュール以上の速さで完走して去っていくその姿は、まさに Just Do It でした。</p>\n\n<p><i class=\"fa fa-github\" aria-hidden=\"true\"></i> <a href=\"https://github.com/namikingsoft\">namikingsoft</a></p>\n\n<h2>周囲の賞賛・承認を共有するよい機会に</h2>\n\n<p>以上、延べ9名の受賞者でした。</p>\n\n<p>表彰コメントは、<strong>開発メンバー同士の投票時に自由記述できるコメントがもとになっているので</strong>、周囲からの賞賛・承認の声を全社で共有できるよい機会となっています。</p>\n\n<p>前回に引き続き連続受賞しているメンバーもいますが、投票コメントには毎回違ったエピソードが集まっており、日ごろから継続的に実践をしているからこそ周りのエンジニアの目に留まるのだと感じました。</p>\n\n<p>受賞者のみなさん、おめでとうございました！</p>\n","contentSnippet":"こんにちは。人事の今岡と申します。2021年もあっという間に6月ですね。フィードフォースでは先日オンライン納会が開催され、半期に一度の「Engineer’s Principles Award 2021 Summer」の受賞者が発表されました。今回アワードを受賞した開発メンバーと表彰内容をご紹介します。前回の表彰者紹介はコチラdeveloper.feedforce.jpEngineer’s Principles Award とはEngineer’s Principles とは、フィードフォースの開発メンバー向けに現場が主体となって設定した、5つの行動指針です。半期に一度、開発メンバー同士で投票を行い、行動指針の項目ごとに最も体現しているメンバーが選ばれ表彰されます。Engineer’s Principles についてはこちらmedia.feedforce.jp受賞者紹介※表彰コメントは本来社内向けのものであるため一部変更させていただいています。受賞者によって各種アカウントを載せています。🏆「Stay Humble; 常に謙虚であるべし」受賞者@len_prog さん表彰コメント： Len (@len_prog) ,  Blog@katsunn さん表彰コメント：  のもち(@nomo_017)🏆「Be Positive & Proactive; 常に肯定的・主体的であるべし」受賞者@sukechannnn さん表彰コメント：  sukechannnn (@sukechannnn) ,  sukechannnn@daido1976 さん表彰コメント：  Daido Shota (@daido1976) ,    daido1976🏆「Be Prepared; 常に来たるべき機会に備えるべし」受賞者@daido1976 さん表彰コメント：  Daido Shota (@daido1976) ,    daido1976@namikingsoft さん表彰コメント： namikingsoft🏆「Share All; 己の知見、試行、失敗、遍く共有すべし」受賞者@masutaka さん表彰コメント： Takashi Masuda (@masutaka) ,  masutaka ,  Blog@kogai さん表彰コメント： 茶碗 (@iamchawan) , kogai ,  Blog🏆「Just Do It; 全力でやりきるべし」受賞者@namikingsoftさん表彰コメント： namikingsoft周囲の賞賛・承認を共有するよい機会に以上、延べ9名の受賞者でした。表彰コメントは、開発メンバー同士の投票時に自由記述できるコメントがもとになっているので、周囲からの賞賛・承認の声を全社で共有できるよい機会となっています。前回に引き続き連続受賞しているメンバーもいますが、投票コメントには毎回違ったエピソードが集まっており、日ごろから継続的に実践をしているからこそ周りのエンジニアの目に留まるのだと感じました。受賞者のみなさん、おめでとうございました！","link":"https://developer.feedforce.jp/entry/2021/06/11/164253","isoDate":"2021-06-11T07:42:53.000Z","dateMiliSeconds":1623397373000,"imageUrl":"https://cdn.user.blog.st-hatena.com/default_entry_og_image/4268819/1588226000876991","authorName":"feedforce"},{"title":"プランニングの難しさを乗り越えて...スクラム開発が良い感じになった話","content":"<p>こんにちは。フィードフォースの <a href=\"https://ecbooster.jp/\">EC Booster</a> チームで開発（主にプロダクトオーナー）をしている <a href=\"https://twitter.com/sukechannnn\">@sukechannnn</a> です。元々ずっとバックエンドエンジニアでしたが、最近プロダクトオーナーをやるようになりました（理由はのちほど！）。</p>\n\n<p>昨年のアドベントカレンダーで <a href=\"https://developer.feedforce.jp/entry/2020/12/11/172338\">半年モブプロしたらチームが大きく成長した話</a> というブログを書いたのですが、2021年3月から <strong>モブプロを取り入れたスクラム開発</strong> をしています。それに伴って、\"モブプロ\" と \"個人タスク⇢レビュー\" の両軸で開発するようになりました（<a href=\"https://prtimes.jp/main/html/rd/p/000000040.000071307.html\">先日リリースしたカイゼンカード</a> はスクラムで開発しました）。</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fdeveloper.feedforce.jp%2Fentry%2F2020%2F12%2F11%2F172338\" title=\"半年モブプロしたらチームが大きく成長した話 - Feedforce Developer Blog\" class=\"embed-card embed-blogcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 190px; max-width: 500px; margin: 10px 0px;\"></iframe></p>\n\n<p>今は良い感じに回っていますが、そうなるまでに色々と試行錯誤したので、そこで得た学びをお伝えできればと思います。全員リモートワークで開発するなら、モブプロを取り入れたスクラムはおすすめです！</p>\n\n<ul class=\"table-of-contents\">\n    <li><a href=\"#モブプロの良さと難しさ\">モブプロの良さと難しさ</a></li>\n    <li><a href=\"#そうだスクラムしよう\">そうだ、スクラムしよう！</a></li>\n    <li><a href=\"#プランニングが終わらない問題\">プランニングが終わらない問題</a></li>\n    <li><a href=\"#原因はissue-が散らかっていることだった\">原因は「issue が散らかっていること」だった</a></li>\n    <li><a href=\"#issue-をグルーピング優先順位はそれぞれで\">issue をグルーピング、優先順位はそれぞれで</a></li>\n    <li><a href=\"#まとめ\">まとめ</a></li>\n</ul>\n\n<h2 id=\"モブプロの良さと難しさ\">モブプロの良さと難しさ</h2>\n\n<p>モブプロ中心の開発を初めた当初は、以下の利点を感じていました。</p>\n\n<ul>\n<li>ドメイン知識の共有がしやすい</li>\n<li>コンテキストの共有がしやすい（\"何をどう作るか\" という議論もしやすい）</li>\n<li>レビューが要らない</li>\n<li>リモートワークでもさみしくない（だいじ）</li>\n</ul>\n\n\n<p>しばらくモブプロを続ける中で、開発メンバー全員がドメイン知識やフロント〜バックエンド全体の技術的な知識を共有している状態になりました。なので、なにか悩みがあってモブプロで共有すると「わかる〜」となるし、何より単純に仲良くなったと思います（ﾖｼｯ!!）。</p>\n\n<p>一方で、だんだんと <strong>モブプロだけ</strong> の開発が窮屈になってきました。</p>\n\n<ul>\n<li>知識の共有が進んできて \"全員でやらなくても良くない？\" というタスクが増えてきた</li>\n<li>個人でじっくり考えた方が良いタスクもあるのが分かった（新しい技術の調査、設計の見直しなど）</li>\n</ul>\n\n\n<p>これはチームが成長したことで出てきた嬉しい悩みなのですが、とはいえ完全にモブプロを辞めるのも上述したメリットを失いそうで怖い...。チーム全員で「今後どう開発していこう？」というのを話し合い、<strong>モブプロを取り入れたスクラム開発</strong> を試してみることにしました。</p>\n\n<h2 id=\"そうだスクラムしよう\">そうだ、スクラムしよう！</h2>\n\n<p>スクラム開発をしようと思ったのは、ストーリーポイント<a href=\"#f-9495249b\" name=\"fn-9495249b\" title=\"ストーリーポイント：プロダクトバックログ（タスク）を見積もるためにチームが使う単位で、前回の見積もりに対する相対評価を用いる\">*1</a>で見積もって <strong>ベロシティ<a href=\"#f-33d76d3d\" name=\"fn-33d76d3d\" title=\"ベロシティ：スプリントの期間でチームが届けることができる見積もり（ストーリーポイント）の合計のこと\">*2</a>を測りたい</strong> という別の目的もありました。</p>\n\n<p>モブプロで開発していると新機能のメイン開発は着実に進んでいくのですが、それ以外の細かいタスク（主に保守系）が見積もりづらい状況で、空いた時間にやるという形になってしまっていました（それ用に時間は設けていましたが）。</p>\n\n<p>モブプロ以外の個人タスクを計画的にやりたい、見積もりもしっかりやりたい、ということで、スクラムを導入することで、<strong>モブプロと個人開発のいいとこ取り</strong> をしようと考えました。</p>\n\n<ul>\n<li>新機能開発などのコンテキストの共有が重要なタスクは引き続きモブプロでやる\n\n<ul>\n<li>ストーリーポイントで見積もる</li>\n</ul>\n</li>\n<li>それ以外は個人タスクとして各自で進められるように、プランニングでしっかり整理する\n\n<ul>\n<li>個人タスクもストーリーポイントで見積もる</li>\n</ul>\n</li>\n<li>全てのタスクをストーリーポイントで見積もるのでベロシティが測れるようになる\n\n<ul>\n<li>振り返りで見積もりの精度を上げられる</li>\n</ul>\n</li>\n</ul>\n\n\n<p>めっちゃ良さそう...そう思っていざやってみたところ、１つ大きな壁にぶち当たってしまいました。</p>\n\n<h2 id=\"プランニングが終わらない問題\">プランニングが終わらない問題</h2>\n\n<p><a href=\"https://www.shoeisha.co.jp/book/detail/9784798130507\">エッセンシャルスクラム</a>にもある通り、１週間のプランニングに２時間以上かけるべきではありません。僕らは「１スプリント=１週間」で回しているため、２時間の予定で始めたプランニングですが、これが終わらない...。最初から何回かは４時間以上かかり、全員ヘトヘトになってしまいました。</p>\n\n<p>モブプロはプランニングが簡単です。全員やることが同じなので、基本的にタスクが直列で繋がっていきます。そのため「今スプリントはここから⇢ここまで」という感じで Sprint Backlog 的なものを決めることができました。</p>\n\n<p>しかし、スクラムの見積もりはもっと横断的なものです。単純に、今取り組んでいるものだけ見れば良いのではなく、これから取り組むものをたくさんある issue から選ぶ必要があります。そう、この <strong>たくさんある issue の中から今スプリントにやるタスクを選ぶこと</strong> に時間がかかってしまうのです。</p>\n\n<p>以前にもスクラム開発を試したことがあるのですが、その時もこれが原因でプランニングがとても大変でした。気にするトピックが多すぎてだんだん何について議論してるか分からなくなり、空中戦になってしまうんですよね...。</p>\n\n<p>その原因は、主に以下の２つでした。</p>\n\n<ul>\n<li>バックログの整理/管理に責任を持つ人（プロダクトオーナー<a href=\"#f-339964b7\" name=\"fn-339964b7\" title=\"プロダクトオーナー：プロダクトバックログの管理をする人で、優先順位を付けることに責任を持つ（１人の人間が務める、委員会ではない）\">*3</a>）がいなかった</li>\n<li>issue の数と種類が多く、バックログリファインメント<a href=\"#f-f2375d03\" name=\"fn-f2375d03\" title=\"バックログリファインメント：プランニングの前にプロダクトバックログを見直し、プランニング可能な状態にしておくこと\">*4</a>をしても整理しきれなかった</li>\n</ul>\n\n\n<p>プロダクトオーナー不在の問題は、元々それっぽいことをしていた僕が、改めてプロダクトオーナーやりますと手を上げ、バックログ管理の責任を持つことになりました。</p>\n\n<p>それでも、バックログリファインメントが上手く行かない問題は残っていました。リファインメントの概念は理解していて、しっかり時間も取っていたのに、いざプランニングをすると色々な issue を見すぎて伸びてしまう...。過去に何度も直面したこの問題に、改めて取り組むことにしました。</p>\n\n<h2 id=\"原因はissue-が散らかっていることだった\">原因は「issue が散らかっていること」だった</h2>\n\n<p>僕たちが開発している EC Booster は、ショッピング広告の自動運用やデータフィードの更新など、様々なジョブが裏で動いています。そのため、運用作業が日々発生し、運用の中で見つかる例外ケースやバグの修正が多々あります。\nまた、フロントエンドとバックエンドを全員が開発するため、１つのリポジトリで管理していることもあり、色々な種類の issue が１つのレーンに入り乱れてしまっていました。</p>\n\n<p>そのため、優先順位を付けるのも難しく、また「次スプリントで何をどこまでやるか？」を判断するのが難しくなってしまっていました。</p>\n\n<p>プロダクトバックログを整理しなければ、というのは分かっているのですが、スクラムに関する本やブログには整理の方法は書いてありません。どうやって整理したら分かりやすくなるかな...と考えていたところ、同僚が共有してくれた以下の記事が参考になりました。</p>\n\n<p><a href=\"https://note.com/gonjyu/n/nd7bf3efa0728\">エンジニア歴17年の俺が、事業系の開発タスクをバンバン投げてくる非エンジニアに、保守の必要性を死ぬほど分かりやすく説明する。</a></p>\n\n<p>この記事の中で「issueには \"種類\" がある」と言っていて、issue の種類別に整理された図が載っていました。これだ...！</p>\n\n<h2 id=\"issue-をグルーピング優先順位はそれぞれで\">issue をグルーピング、優先順位はそれぞれで</h2>\n\n<p>上記の記事を参考に、issue を <strong>新機能開発</strong>、<strong>バグ修正/運用改善</strong>、<strong>ライブラリーアップデート</strong> に分けて、それぞれのレーンで優先順位を付けるようにしました。</p>\n\n<p><figure class=\"figure-image figure-image-fotolife\" title=\"issue をグルーピング、優先順位はそれぞれで\"><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/s/sukechannnn/20210526/20210526215948.png\" alt=\"f:id:sukechannnn:20210526215948p:plain\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span><figcaption>issue をグルーピング、優先順位はそれぞれで</figcaption></figure></p>\n\n<p>issue の種類が同じなので、優先順位を付けるのは簡単です。さらに、スプリントバックログに入れるタスクを <strong>新機能開発：運用系 = ６：４</strong> の割合にする、という決めを作りました。さらに、何回かスプリントを回してベロシティも見えてきました。</p>\n\n<p>ここまで情報が揃うと <strong>次のスプリントで何をやるか決める基準</strong> ができてきます。</p>\n\n<p>そもそもの「次のプランニングでどの issue について話すか？」というのも、それぞれのレーンで優先順位が高い issue を６：４のバランスとベロシティを参考に選べるようになりました。<strong>プランニングの前</strong>にプロダクトオーナーが（開発チームと協力しながら）当たりを付けておくことで、プランニングで話すトピックを事前に共有できるようになり、開発メンバーそれぞれが事前に頭を整理しておくこともできるようになりました。</p>\n\n<p>これにより、プランニングがかなりスムーズに進むようになったので、いよいよスクラムが回り始めました。新機能開発はモブプロの同期的な開発で、それ以外のタスクは個人タスク⇢レビューという非同期な開発で進められるようになり、デリバリーの最大化を目指しつつ、個人の稼働率も上げられるようになりました。</p>\n\n<p><figure class=\"figure-image figure-image-fotolife\" title=\"GitHub Project を使ってタスク管理してる様子...横に長いんですが、情報が整理されてる方が優先順位を付けやすい\"><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/s/sukechannnn/20210526/20210526212511.png\" alt=\"f:id:sukechannnn:20210526212511p:plain\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span><figcaption>GitHub Project を使ってタスク管理してる様子...横に長いんですが、情報が整理されてる方が優先順位を付けやすい</figcaption></figure></p>\n\n<h2 id=\"まとめ\">まとめ</h2>\n\n<p>issue をグルーピングしそれぞれで優先順位を付けたことで、プランニングが時間内に収まるようになっただけでなく、プランニングで話すトピックを絞ったことでより深い議論をすることができるようになりました。今は「モブプロを取り入れたスクラム」がとても良い感じに回っています！</p>\n\n<p>↓ EC Booster チームでの「スプリントの回し方」資料を公開しているので、気になった方はぜひ見てみてください！（もっとこうしたら良いよ！という助言などあれば頂けると嬉しいです！）</p>\n\n<iframe src=\"https://docs.google.com/presentation/d/e/2PACX-1vTQY639rUAwDDtLfj_c9WbU1E0IlDSFzAbrP-XFCmbg8V_sNKPX_pCvKpiy50CQpS02nXvZnQHBb6JT/embed?start=false&loop=false&delayms=3000\" frameborder=\"0\" width=\"960\" height=\"569\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\n\n\n<p>こんな感じ開発している EC Booster ですが、ただ今 <strong>バックエンド（Ruby, Rails）が得意なエンジニアを猛烈に必要としています！！！</strong></p>\n\n<p>もしちょっっっとでも興味があれば、 <strong>僕とお話しましょう！</strong> 以下から気軽に応募してください！\n<a href=\"https://open.talentio.com/1/c/feedforce/requisitions/detail/19785\">https://open.talentio.com/1/c/feedforce/requisitions/detail/19785</a></p>\n\n<p>最後まで読んでいただき、ありがとうございました！</p>\n<div class=\"footnote\">\n<p class=\"footnote\"><a href=\"#fn-9495249b\" name=\"f-9495249b\" class=\"footnote-number\">*1</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\"><a href=\"https://www.ryuzee.com/contents/blog/3716\">ストーリーポイント</a>：プロダクトバックログ（タスク）を見積もるためにチームが使う単位で、前回の見積もりに対する相対評価を用いる</span></p>\n<p class=\"footnote\"><a href=\"#fn-33d76d3d\" name=\"f-33d76d3d\" class=\"footnote-number\">*2</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\"><a href=\"https://www.ryuzee.com/contents/blog/4802\">ベロシティ</a>：スプリントの期間でチームが届けることができる見積もり（ストーリーポイント）の合計のこと</span></p>\n<p class=\"footnote\"><a href=\"#fn-339964b7\" name=\"f-339964b7\" class=\"footnote-number\">*3</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\"><a href=\"https://www.ryuzee.com/contents/blog/7143\">プロダクトオーナー</a>：プロダクトバックログの管理をする人で、優先順位を付けることに責任を持つ（１人の人間が務める、委員会ではない）</span></p>\n<p class=\"footnote\"><a href=\"#fn-f2375d03\" name=\"f-f2375d03\" class=\"footnote-number\">*4</a><span class=\"footnote-delimiter\">:</span><span class=\"footnote-text\"><a href=\"https://www.ryuzee.com/contents/blog/5024\">バックログリファインメント</a>：プランニングの前にプロダクトバックログを見直し、プランニング可能な状態にしておくこと</span></p>\n</div>","contentSnippet":"こんにちは。フィードフォースの EC Booster チームで開発（主にプロダクトオーナー）をしている @sukechannnn です。元々ずっとバックエンドエンジニアでしたが、最近プロダクトオーナーをやるようになりました（理由はのちほど！）。昨年のアドベントカレンダーで 半年モブプロしたらチームが大きく成長した話 というブログを書いたのですが、2021年3月から モブプロを取り入れたスクラム開発 をしています。それに伴って、\"モブプロ\" と \"個人タスク⇢レビュー\" の両軸で開発するようになりました（先日リリースしたカイゼンカード はスクラムで開発しました）。今は良い感じに回っていますが、そうなるまでに色々と試行錯誤したので、そこで得た学びをお伝えできればと思います。全員リモートワークで開発するなら、モブプロを取り入れたスクラムはおすすめです！モブプロの良さと難しさそうだ、スクラムしよう！プランニングが終わらない問題原因は「issue が散らかっていること」だったissue をグルーピング、優先順位はそれぞれでまとめモブプロの良さと難しさモブプロ中心の開発を初めた当初は、以下の利点を感じていました。ドメイン知識の共有がしやすいコンテキストの共有がしやすい（\"何をどう作るか\" という議論もしやすい）レビューが要らないリモートワークでもさみしくない（だいじ）しばらくモブプロを続ける中で、開発メンバー全員がドメイン知識やフロント〜バックエンド全体の技術的な知識を共有している状態になりました。なので、なにか悩みがあってモブプロで共有すると「わかる〜」となるし、何より単純に仲良くなったと思います（ﾖｼｯ!!）。一方で、だんだんと モブプロだけ の開発が窮屈になってきました。知識の共有が進んできて \"全員でやらなくても良くない？\" というタスクが増えてきた個人でじっくり考えた方が良いタスクもあるのが分かった（新しい技術の調査、設計の見直しなど）これはチームが成長したことで出てきた嬉しい悩みなのですが、とはいえ完全にモブプロを辞めるのも上述したメリットを失いそうで怖い...。チーム全員で「今後どう開発していこう？」というのを話し合い、モブプロを取り入れたスクラム開発 を試してみることにしました。そうだ、スクラムしよう！スクラム開発をしようと思ったのは、ストーリーポイント*1で見積もって ベロシティ*2を測りたい という別の目的もありました。モブプロで開発していると新機能のメイン開発は着実に進んでいくのですが、それ以外の細かいタスク（主に保守系）が見積もりづらい状況で、空いた時間にやるという形になってしまっていました（それ用に時間は設けていましたが）。モブプロ以外の個人タスクを計画的にやりたい、見積もりもしっかりやりたい、ということで、スクラムを導入することで、モブプロと個人開発のいいとこ取り をしようと考えました。新機能開発などのコンテキストの共有が重要なタスクは引き続きモブプロでやるストーリーポイントで見積もるそれ以外は個人タスクとして各自で進められるように、プランニングでしっかり整理する個人タスクもストーリーポイントで見積もる全てのタスクをストーリーポイントで見積もるのでベロシティが測れるようになる振り返りで見積もりの精度を上げられるめっちゃ良さそう...そう思っていざやってみたところ、１つ大きな壁にぶち当たってしまいました。プランニングが終わらない問題エッセンシャルスクラムにもある通り、１週間のプランニングに２時間以上かけるべきではありません。僕らは「１スプリント=１週間」で回しているため、２時間の予定で始めたプランニングですが、これが終わらない...。最初から何回かは４時間以上かかり、全員ヘトヘトになってしまいました。モブプロはプランニングが簡単です。全員やることが同じなので、基本的にタスクが直列で繋がっていきます。そのため「今スプリントはここから⇢ここまで」という感じで Sprint Backlog 的なものを決めることができました。しかし、スクラムの見積もりはもっと横断的なものです。単純に、今取り組んでいるものだけ見れば良いのではなく、これから取り組むものをたくさんある issue から選ぶ必要があります。そう、この たくさんある issue の中から今スプリントにやるタスクを選ぶこと に時間がかかってしまうのです。以前にもスクラム開発を試したことがあるのですが、その時もこれが原因でプランニングがとても大変でした。気にするトピックが多すぎてだんだん何について議論してるか分からなくなり、空中戦になってしまうんですよね...。その原因は、主に以下の２つでした。バックログの整理/管理に責任を持つ人（プロダクトオーナー*3）がいなかったissue の数と種類が多く、バックログリファインメント*4をしても整理しきれなかったプロダクトオーナー不在の問題は、元々それっぽいことをしていた僕が、改めてプロダクトオーナーやりますと手を上げ、バックログ管理の責任を持つことになりました。それでも、バックログリファインメントが上手く行かない問題は残っていました。リファインメントの概念は理解していて、しっかり時間も取っていたのに、いざプランニングをすると色々な issue を見すぎて伸びてしまう...。過去に何度も直面したこの問題に、改めて取り組むことにしました。原因は「issue が散らかっていること」だった僕たちが開発している EC Booster は、ショッピング広告の自動運用やデータフィードの更新など、様々なジョブが裏で動いています。そのため、運用作業が日々発生し、運用の中で見つかる例外ケースやバグの修正が多々あります。また、フロントエンドとバックエンドを全員が開発するため、１つのリポジトリで管理していることもあり、色々な種類の issue が１つのレーンに入り乱れてしまっていました。そのため、優先順位を付けるのも難しく、また「次スプリントで何をどこまでやるか？」を判断するのが難しくなってしまっていました。プロダクトバックログを整理しなければ、というのは分かっているのですが、スクラムに関する本やブログには整理の方法は書いてありません。どうやって整理したら分かりやすくなるかな...と考えていたところ、同僚が共有してくれた以下の記事が参考になりました。エンジニア歴17年の俺が、事業系の開発タスクをバンバン投げてくる非エンジニアに、保守の必要性を死ぬほど分かりやすく説明する。この記事の中で「issueには \"種類\" がある」と言っていて、issue の種類別に整理された図が載っていました。これだ...！issue をグルーピング、優先順位はそれぞれで上記の記事を参考に、issue を 新機能開発、バグ修正/運用改善、ライブラリーアップデート に分けて、それぞれのレーンで優先順位を付けるようにしました。issue をグルーピング、優先順位はそれぞれでissue の種類が同じなので、優先順位を付けるのは簡単です。さらに、スプリントバックログに入れるタスクを 新機能開発：運用系 = ６：４ の割合にする、という決めを作りました。さらに、何回かスプリントを回してベロシティも見えてきました。ここまで情報が揃うと 次のスプリントで何をやるか決める基準 ができてきます。そもそもの「次のプランニングでどの issue について話すか？」というのも、それぞれのレーンで優先順位が高い issue を６：４のバランスとベロシティを参考に選べるようになりました。プランニングの前にプロダクトオーナーが（開発チームと協力しながら）当たりを付けておくことで、プランニングで話すトピックを事前に共有できるようになり、開発メンバーそれぞれが事前に頭を整理しておくこともできるようになりました。これにより、プランニングがかなりスムーズに進むようになったので、いよいよスクラムが回り始めました。新機能開発はモブプロの同期的な開発で、それ以外のタスクは個人タスク⇢レビューという非同期な開発で進められるようになり、デリバリーの最大化を目指しつつ、個人の稼働率も上げられるようになりました。GitHub Project を使ってタスク管理してる様子...横に長いんですが、情報が整理されてる方が優先順位を付けやすいまとめissue をグルーピングしそれぞれで優先順位を付けたことで、プランニングが時間内に収まるようになっただけでなく、プランニングで話すトピックを絞ったことでより深い議論をすることができるようになりました。今は「モブプロを取り入れたスクラム」がとても良い感じに回っています！↓ EC Booster チームでの「スプリントの回し方」資料を公開しているので、気になった方はぜひ見てみてください！（もっとこうしたら良いよ！という助言などあれば頂けると嬉しいです！）こんな感じ開発している EC Booster ですが、ただ今 バックエンド（Ruby, Rails）が得意なエンジニアを猛烈に必要としています！！！もしちょっっっとでも興味があれば、 僕とお話しましょう！ 以下から気軽に応募してください！https://open.talentio.com/1/c/feedforce/requisitions/detail/19785最後まで読んでいただき、ありがとうございました！*1:ストーリーポイント：プロダクトバックログ（タスク）を見積もるためにチームが使う単位で、前回の見積もりに対する相対評価を用いる*2:ベロシティ：スプリントの期間でチームが届けることができる見積もり（ストーリーポイント）の合計のこと*3:プロダクトオーナー：プロダクトバックログの管理をする人で、優先順位を付けることに責任を持つ（１人の人間が務める、委員会ではない）*4:バックログリファインメント：プランニングの前にプロダクトバックログを見直し、プランニング可能な状態にしておくこと","link":"https://developer.feedforce.jp/entry/2021/05/31/104813","isoDate":"2021-05-31T01:48:13.000Z","dateMiliSeconds":1622425693000,"imageUrl":"https://cdn-ak.f.st-hatena.com/images/fotolife/s/sukechannnn/20210526/20210526215948.png","authorName":"feedforce"},{"title":"エンジニアキャリアパスをアップデートしました","content":"<p>こんにちは、<a href=\"https://twitter.com/meihong\">meihong</a> です。</p>\n\n<p>株式会社フィードフォースでは<a href=\"https://media.feedforce.jp/n/nc7a2e89635eb\">定期評価ではなく本人の希望するタイミングで評価を行う制度</a>を導入しています。具体的には、各等級ごとに満たすべき基準・条件、またはスキルがあらかじめ提示されており、それを満たしていれば次の等級に進める制度になります。</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fmedia.feedforce.jp%2Fn%2Fn222a08fd3e2b\" title=\"半年に1回の評価制度を毎月の評価制度に変えた話｜フィードフォースのnote\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://media.feedforce.jp/n/n222a08fd3e2b\">media.feedforce.jp</a></cite></p>\n\n<p>この基準やスキルを私たちはキャリアパスと呼んでいますが、今回、エンジニアのキャリアパスをアップデートしましたのでご紹介したいと思います。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/m/meihong/20210524/20210524010544.png\" alt=\"f:id:meihong:20210524010544p:plain\" width=\"1200\" height=\"630\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<h2>なぜキャリアパスをアップデートしたのか</h2>\n\n<p>もともとのキャリアパスは<a href=\"https://media.feedforce.jp/n/n222a08fd3e2b\">導入当初に設計されたもの</a>をベースに、マネージャやエンジニア、新規事業向けエンジニアといった個々人の志向に応じて細分化されていました。</p>\n\n<p>これはこれでよくできたものだったのですが、しばらく運用している中でいくつかの課題点を感じるようになってきました。\n例えば、</p>\n\n<ul>\n<li>志向ごとに分かれすぎていて、志向を横断した動きが想定しづらくなった。</li>\n<li>独り立ちと判断される等級であるメンバーとその一つ上のシニアの境界に「見えない高い壁」が存在するようになった。</li>\n<li>シニア以上の等級になるとチームや会社を牽引することを求められ、技術をそれ以上深掘りすることに対して会社がどう考えているのかが見えづらくなった。</li>\n</ul>\n\n\n<p>といったところです。</p>\n\n<p>特にキャリアパス全体として、職種問わず等級が上がれば上がるほどチームや会社への影響力が求められる設計になっています。</p>\n\n<p>もちろんエンジニアも全体への影響力は持つべきなのですが、その持ち方は他の職種と異なり、技術力の広さ、深さといった持ち方もあるのではないかと考えるようになりました。</p>\n\n<p>ここで、個人的にはプロフェッショナルとしてのスキルは体積であり、その底面積はスキルの幅広さだと考えています。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/m/meihong/20210523/20210523235853.png\" alt=\"f:id:meihong:20210523235853p:plain\" width=\"1200\" height=\"731\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>極端に底面積が狭いのはさすがに現時点では厳しいとは思いますが、</p>\n\n<ul>\n<li>底面積がそれなりである代わりに高さ(= 深さ)がある</li>\n<li>底面積が広い (= 引き出しが多い) 反面高さはそこまででもない</li>\n</ul>\n\n\n<p>の両者は体積という意味では同じはずです。</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/m/meihong/20210524/20210524000640.png\" alt=\"f:id:meihong:20210524000640p:plain\" width=\"1200\" height=\"576\" loading=\"lazy\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>この両者が共存できる余地が欲しいと考えていました。</p>\n\n<p>そんな中、弊社デザイナーのキャリアパスがアップデートされました。その中でも目を引いたのは、必須スキルと専門スキルという考え方です。</p>\n\n<p>必須スキルはデザイナーとして必ず持っていて欲しいスキルである一方、専門スキルは本人の志向、特性に応じてピックアップできるというもので、大学の専攻を思い出す建て付けでした。</p>\n\n<p><s>これをパクる</s>これにインスパイアされて、エンジニアのキャリアパスもアップデートすることにしました。</p>\n\n<h2>どのように更新したのか</h2>\n\n<p>結果から先にお伝えしておくと、大まかに以下のような方向性に改訂しました。</p>\n\n<ul>\n<li>志向ごとのキャリアパスは止めた。</li>\n<li>旧来の「志向」を専門スキルに分解し、専門スキルの組み合わせで個々人の志向・特性を表現できるようにした。</li>\n<li>等級が上がれば上がるほど満たすべき専門スキルの最低数が増えるようにした。</li>\n</ul>\n\n\n<p>その結果として、例えば</p>\n\n<ul>\n<li>バックエンドエンジニアに特化</li>\n<li>フルスタックエンジニア</li>\n<li>フルスタックな知識をベースに事業の 0 → 1 フェイズに参画できるエンジニア</li>\n<li>カスタマーサクセスエンジニア</li>\n<li>アジャイルコーチ</li>\n</ul>\n\n\n<p>といった、実際に社内に存在している各エンジニアの志向や得意なポイントを表現できるようになりました。</p>\n\n<h2>産みの苦しみ</h2>\n\n<p>ここに至るまでには色々な葛藤がありました。\n社内の esa にキャリアパスを更新したいと宣言はしたものの、社内のエンジニア個々人の顔を思い浮かべつつ何を専門スキルとして設定するかを考えると想像以上に難しい問題だということに気付きました。</p>\n\n<h3>必須スキルと専門スキル</h3>\n\n<p>そもそも必須スキルと専門スキルとは何か、そこの定義から考えることにしました。</p>\n\n<p>必須スキルとは文字通り、全てのエンジニアが共通に要求されるスキルセットのことです。どちらかというと「バックエンド」「フロントエンド」といった用語で定義されるスキルセットというよりも「フィードフォースに所属するエンジニアとしての振る舞い方」ではないでしょうか。</p>\n\n<p>そう考えながら改訂前のキャリアパスを改めて眺めていると、改訂前のキャリアパスはその振る舞いを定義していることに気付きました。その結果、改訂前のキャリアパスが必須スキルのベースとなりました。</p>\n\n<p>そうです、キャリアパスの改訂によって、より要求水準が上がったとも言えます。</p>\n\n<p>一方、専門スキルは、本人の得意分野、志向、特性を定義するものです。\nその志向・方向性で貢献するのであれば、各等級ごとにどの水準の成果を出すべきか。それを定義するものが専門スキルになります。</p>\n\n<h3>専門スキルとはどうあるべきか</h3>\n\n<p>本人の志向を定義するものが専門スキルと説明しましたが、例えばカスタマーサクセスエンジニアやエンジニアリングマネージャといった職種にしてもエンジニアの延長である以上はエンジニアとしての「共通言語」を身につけているべきです。</p>\n\n<p>その「共通言語」とは、例えば設計力であったり、フロントエンドやバックエンドのスキルが該当します。</p>\n\n<p>こういった知識を前提として例えば事業開発であったりチームビルディングを行うべきで、これらの知識がなければエンジニアとの「共通言語」を持っていないと判断せざるを得ません。</p>\n\n<p>一方で、「フロントエンド力」と「バックエンド力」が同じくらい強いエンジニアというのは SSR エンジニアで、そうそう市場には存在しません。そこで、フルスタックとはいえどこかの分野に軸足を置くことができる制度というのも必須に感じました。</p>\n\n<p>ただ、ここの軸足とはあくまでも「フロントエンド」「バックエンド」「インフラ」といった区分けで、エンジニアとしてコードを書き続ける選択をするのであれば、フロントエンド/バックエンド/インフラといった区分に関係なく設計力・実装力が担保されているべきでしょう。</p>\n\n<h3>17 の専門スキル</h3>\n\n<p>ここのバランス感が非常に難しい点でしたが、これを元に 17 の専門スキルを定義しました。\nただし、17 の専門スキルは完全に独立しているわけではなく、以下 6 つは本人の志向を定義するものとして、必ずどれか一つが必須選択としました。</p>\n\n<ul>\n<li>バックエンド</li>\n<li>フロントエンド</li>\n<li>データベース</li>\n<li>基盤</li>\n<li>カスタマーサクセス</li>\n<li>組織支援</li>\n</ul>\n\n\n<p>さらに、上記のうち以下 4 つを選択した場合は「実装・設計」と呼ばれるスキルが必須となります。</p>\n\n<ul>\n<li>バックエンド</li>\n<li>フロントエンド</li>\n<li>データベース</li>\n<li>基盤</li>\n</ul>\n\n\n<p>これにより、コードを書き続けるのであればただコードを書くだけでなく、実装力・設計力が要求される建て付けを実現しました。</p>\n\n<p>また、詳細は省きますが、さらにいくつかの例外を設置することで、「全ての分野で等しく強い SSR なフルスタックエンジニア」が求められないようにしています。</p>\n\n<hr />\n\n<p>様々なエッジケースを考慮したせいでちょっと複雑になった感の否めない新しいキャリアパスですが、以前のものと比べるとその分より柔軟なものになったと思います。</p>\n\n<p>今回は敢えて詳細を省きましたが、<a href=\"https://engineers.recruit.feedforce.jp/#entry\">ご興味をお持ちいただけたら是非カジュアル面談でねっちょりとご説明します</a>！</p>\n","contentSnippet":"こんにちは、meihong です。株式会社フィードフォースでは定期評価ではなく本人の希望するタイミングで評価を行う制度を導入しています。具体的には、各等級ごとに満たすべき基準・条件、またはスキルがあらかじめ提示されており、それを満たしていれば次の等級に進める制度になります。media.feedforce.jpこの基準やスキルを私たちはキャリアパスと呼んでいますが、今回、エンジニアのキャリアパスをアップデートしましたのでご紹介したいと思います。なぜキャリアパスをアップデートしたのかもともとのキャリアパスは導入当初に設計されたものをベースに、マネージャやエンジニア、新規事業向けエンジニアといった個々人の志向に応じて細分化されていました。これはこれでよくできたものだったのですが、しばらく運用している中でいくつかの課題点を感じるようになってきました。例えば、志向ごとに分かれすぎていて、志向を横断した動きが想定しづらくなった。独り立ちと判断される等級であるメンバーとその一つ上のシニアの境界に「見えない高い壁」が存在するようになった。シニア以上の等級になるとチームや会社を牽引することを求められ、技術をそれ以上深掘りすることに対して会社がどう考えているのかが見えづらくなった。といったところです。特にキャリアパス全体として、職種問わず等級が上がれば上がるほどチームや会社への影響力が求められる設計になっています。もちろんエンジニアも全体への影響力は持つべきなのですが、その持ち方は他の職種と異なり、技術力の広さ、深さといった持ち方もあるのではないかと考えるようになりました。ここで、個人的にはプロフェッショナルとしてのスキルは体積であり、その底面積はスキルの幅広さだと考えています。極端に底面積が狭いのはさすがに現時点では厳しいとは思いますが、底面積がそれなりである代わりに高さ(= 深さ)がある底面積が広い (= 引き出しが多い) 反面高さはそこまででもないの両者は体積という意味では同じはずです。この両者が共存できる余地が欲しいと考えていました。そんな中、弊社デザイナーのキャリアパスがアップデートされました。その中でも目を引いたのは、必須スキルと専門スキルという考え方です。必須スキルはデザイナーとして必ず持っていて欲しいスキルである一方、専門スキルは本人の志向、特性に応じてピックアップできるというもので、大学の専攻を思い出す建て付けでした。これをパクるこれにインスパイアされて、エンジニアのキャリアパスもアップデートすることにしました。どのように更新したのか結果から先にお伝えしておくと、大まかに以下のような方向性に改訂しました。志向ごとのキャリアパスは止めた。旧来の「志向」を専門スキルに分解し、専門スキルの組み合わせで個々人の志向・特性を表現できるようにした。等級が上がれば上がるほど満たすべき専門スキルの最低数が増えるようにした。その結果として、例えばバックエンドエンジニアに特化フルスタックエンジニアフルスタックな知識をベースに事業の 0 → 1 フェイズに参画できるエンジニアカスタマーサクセスエンジニアアジャイルコーチといった、実際に社内に存在している各エンジニアの志向や得意なポイントを表現できるようになりました。産みの苦しみここに至るまでには色々な葛藤がありました。社内の esa にキャリアパスを更新したいと宣言はしたものの、社内のエンジニア個々人の顔を思い浮かべつつ何を専門スキルとして設定するかを考えると想像以上に難しい問題だということに気付きました。必須スキルと専門スキルそもそも必須スキルと専門スキルとは何か、そこの定義から考えることにしました。必須スキルとは文字通り、全てのエンジニアが共通に要求されるスキルセットのことです。どちらかというと「バックエンド」「フロントエンド」といった用語で定義されるスキルセットというよりも「フィードフォースに所属するエンジニアとしての振る舞い方」ではないでしょうか。そう考えながら改訂前のキャリアパスを改めて眺めていると、改訂前のキャリアパスはその振る舞いを定義していることに気付きました。その結果、改訂前のキャリアパスが必須スキルのベースとなりました。そうです、キャリアパスの改訂によって、より要求水準が上がったとも言えます。一方、専門スキルは、本人の得意分野、志向、特性を定義するものです。その志向・方向性で貢献するのであれば、各等級ごとにどの水準の成果を出すべきか。それを定義するものが専門スキルになります。専門スキルとはどうあるべきか本人の志向を定義するものが専門スキルと説明しましたが、例えばカスタマーサクセスエンジニアやエンジニアリングマネージャといった職種にしてもエンジニアの延長である以上はエンジニアとしての「共通言語」を身につけているべきです。その「共通言語」とは、例えば設計力であったり、フロントエンドやバックエンドのスキルが該当します。こういった知識を前提として例えば事業開発であったりチームビルディングを行うべきで、これらの知識がなければエンジニアとの「共通言語」を持っていないと判断せざるを得ません。一方で、「フロントエンド力」と「バックエンド力」が同じくらい強いエンジニアというのは SSR エンジニアで、そうそう市場には存在しません。そこで、フルスタックとはいえどこかの分野に軸足を置くことができる制度というのも必須に感じました。ただ、ここの軸足とはあくまでも「フロントエンド」「バックエンド」「インフラ」といった区分けで、エンジニアとしてコードを書き続ける選択をするのであれば、フロントエンド/バックエンド/インフラといった区分に関係なく設計力・実装力が担保されているべきでしょう。17 の専門スキルここのバランス感が非常に難しい点でしたが、これを元に 17 の専門スキルを定義しました。ただし、17 の専門スキルは完全に独立しているわけではなく、以下 6 つは本人の志向を定義するものとして、必ずどれか一つが必須選択としました。バックエンドフロントエンドデータベース基盤カスタマーサクセス組織支援さらに、上記のうち以下 4 つを選択した場合は「実装・設計」と呼ばれるスキルが必須となります。バックエンドフロントエンドデータベース基盤これにより、コードを書き続けるのであればただコードを書くだけでなく、実装力・設計力が要求される建て付けを実現しました。また、詳細は省きますが、さらにいくつかの例外を設置することで、「全ての分野で等しく強い SSR なフルスタックエンジニア」が求められないようにしています。様々なエッジケースを考慮したせいでちょっと複雑になった感の否めない新しいキャリアパスですが、以前のものと比べるとその分より柔軟なものになったと思います。今回は敢えて詳細を省きましたが、ご興味をお持ちいただけたら是非カジュアル面談でねっちょりとご説明します！","link":"https://developer.feedforce.jp/entry/career_path_revised_2021","isoDate":"2021-05-24T02:00:00.000Z","dateMiliSeconds":1621821600000,"imageUrl":"https://cdn-ak.f.st-hatena.com/images/fotolife/m/meihong/20210524/20210524010544.png","authorName":"feedforce"},{"title":"ふりかえりカンファレンスのスタッフをやりました！","content":"<p>こんにちは <a href=\"http://blog.hatena.ne.jp/pokotyamu/\">id:pokotyamu</a> です！\n最近は、モンハンライズにハマっています！ハンマー担いでブンブンしてます！</p>\n\n<p>4月16日(土)に行われた「ふりかえりカンファレンス」のスタッフをやりました！</p>\n\n<p><span itemscope itemtype=\"http://schema.org/Photograph\"><img src=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pokotyamu/20210416/20210416155303.png\" alt=\"f:id:pokotyamu:20210416155303p:plain\" title=\"\" class=\"hatena-fotolife\" itemprop=\"image\"></span></p>\n\n<p>今回はそこでの学びや感じたことを社内勉強会で発表したので、スライドとコメントをまとめます。</p>\n\n<h2>FFTT 発表資料</h2>\n\n<script async class=\"speakerdeck-embed\" data-id=\"1f772bfe5abd4fa28ff738df3a5e76a2\" data-ratio=\"1.77777777777778\" src=\"//speakerdeck.com/assets/embed.js\"></script>\n\n\n<h2>勉強会の感想コメント</h2>\n\n<blockquote><p> なんのためにふりかえりやってるの？</p></blockquote>\n\n<p>明日の自分やチームを1歩でも楽しくなるためにやってほしいですね！\n連続したサイクルの中にふりかえりを組み込むことで、安全に転んで、次の1歩を早く出せるようになると思います！</p>\n\n<blockquote><p>オンラインセミナーは当日参加が多い\n結構人数集まったようなので準備とか大変そう</p></blockquote>\n\n<p>場所の制約がなくなったのが非常に大きいですね〜！\n国内・国外関係なく、どこでもいけるのが本当に便利！</p>\n\n<blockquote><p>振り返り手法ってあんなにたくさんあるのだなぁ\n振り返りの手法も多いようなのでどのタイミングで何を使うのが適切かを考えるの難しそう\n会社やチームよって向き不向きがありそうだけど、選ぶには知らないといけないので専門的な人がいる意味がよく分かる</p></blockquote>\n\n<p>そーなんですよね。\n次の Action を決めたい時や、関係構築したい時など、用途に合わせてやるのがいいと思います！\nもちろん KPT も素晴らしい手法なので、たまに気分を変えてみるみたいな感じでどうぞ！</p>\n\n<blockquote><p>振り返りとの因果関係を感じられる強い人やチームの実例を見たら、もう少しイメージが付くのかな\nと思っていたが、21卒の方の日報をザッピングしていたら、振り返りが役に立った、楽しいという風に書かれていた</p></blockquote>\n\n<p>今年は特に楽しいにフォーカスしてふりかえりをしているのもあると思います！</p>\n\n<blockquote><p>オンラインカンファレンスのスタッフの話って結構レアな気がするので興味深かった</p></blockquote>\n\n<p>楽しいのでぜひぜひ！</p>\n\n<h2>感想</h2>\n\n<p>私は、初めてカンファレンスのスタッフをやらせてもらったのですが、非常に楽しかったです！\n他の人の感想やブログレポートを見るのも、それそれ！その言葉待ってた！という感じでいつもの一般参加とは違う感覚で聞くことができました！</p>\n\n<p>今回のスタッフを経験したことで、「楽しくふりかえる」の意味を体で感じることができたと思います。もちろん当日の発表もどれも素晴らしくてそれも含みで楽しかったところではありましたが ☺️\n気軽に試す、実験してみるを最近のふりかえりでも挑戦中です。</p>\n\n<p>また、オンラインカンファレンスということもあり、夜の2次会が3時ぐらいまで盛り上がっていたのも楽しかったポイントでした。\n新しいつながりも持てたので、社内の知見をどんどん外に発信して自分の魅力を高めていければと思います。</p>\n\n<p>改めて、スタッフに誘っていただいた <a href=\"https://twitter.com/viva_tweet_x\">@viva_tweet_x</a> さんに改めて感謝です！ありがとうございました！これからもよろしくおねがいします！</p>\n","contentSnippet":"こんにちは id:pokotyamu です！最近は、モンハンライズにハマっています！ハンマー担いでブンブンしてます！4月16日(土)に行われた「ふりかえりカンファレンス」のスタッフをやりました！今回はそこでの学びや感じたことを社内勉強会で発表したので、スライドとコメントをまとめます。FFTT 発表資料勉強会の感想コメント なんのためにふりかえりやってるの？明日の自分やチームを1歩でも楽しくなるためにやってほしいですね！連続したサイクルの中にふりかえりを組み込むことで、安全に転んで、次の1歩を早く出せるようになると思います！オンラインセミナーは当日参加が多い結構人数集まったようなので準備とか大変そう場所の制約がなくなったのが非常に大きいですね〜！国内・国外関係なく、どこでもいけるのが本当に便利！振り返り手法ってあんなにたくさんあるのだなぁ振り返りの手法も多いようなのでどのタイミングで何を使うのが適切かを考えるの難しそう会社やチームよって向き不向きがありそうだけど、選ぶには知らないといけないので専門的な人がいる意味がよく分かるそーなんですよね。次の Action を決めたい時や、関係構築したい時など、用途に合わせてやるのがいいと思います！もちろん KPT も素晴らしい手法なので、たまに気分を変えてみるみたいな感じでどうぞ！振り返りとの因果関係を感じられる強い人やチームの実例を見たら、もう少しイメージが付くのかなと思っていたが、21卒の方の日報をザッピングしていたら、振り返りが役に立った、楽しいという風に書かれていた今年は特に楽しいにフォーカスしてふりかえりをしているのもあると思います！オンラインカンファレンスのスタッフの話って結構レアな気がするので興味深かった楽しいのでぜひぜひ！感想私は、初めてカンファレンスのスタッフをやらせてもらったのですが、非常に楽しかったです！他の人の感想やブログレポートを見るのも、それそれ！その言葉待ってた！という感じでいつもの一般参加とは違う感覚で聞くことができました！今回のスタッフを経験したことで、「楽しくふりかえる」の意味を体で感じることができたと思います。もちろん当日の発表もどれも素晴らしくてそれも含みで楽しかったところではありましたが ☺️気軽に試す、実験してみるを最近のふりかえりでも挑戦中です。また、オンラインカンファレンスということもあり、夜の2次会が3時ぐらいまで盛り上がっていたのも楽しかったポイントでした。新しいつながりも持てたので、社内の知見をどんどん外に発信して自分の魅力を高めていければと思います。改めて、スタッフに誘っていただいた @viva_tweet_x さんに改めて感謝です！ありがとうございました！これからもよろしくおねがいします！","link":"https://developer.feedforce.jp/entry/2021/04/19/141153","isoDate":"2021-04-19T05:11:53.000Z","dateMiliSeconds":1618809113000,"imageUrl":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pokotyamu/20210416/20210416155303.png","authorName":"feedforce"},{"title":"エンジニア向けミートアップを開催します！","content":"<p>こんにちは。人事チームからエンジニアミートアップについてお知らせです。</p>\n\n<p>3月26日（金）19：00から、エンジニア向けのミートアップを開催することになりました！\n選考とは関係ないので、純粋に「どんなエンジニアがいるかみてみたい」「会社の雰囲気を知りたい」\nという方もぜひご参加いただけたら嬉しいです。</p>\n\n<p>初回のLT登壇者は <a href=\"https://twitter.com/daido1976\">@daido1976</a>です！</br>\n詳しくは下記記事をご覧ください。</p>\n\n<p><iframe src=\"https://hatenablog-parts.com/embed?url=https%3A%2F%2Fmedia.feedforce.jp%2Fn%2Fn53b8be5eae4a\" title=\"現場エンジニアと気軽に話せる！エンジニアミートアップを開催します｜フィードフォースのnote\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://media.feedforce.jp/n/n53b8be5eae4a\">media.feedforce.jp</a></cite></p>\n\n<p>ご参加お待ちしています！</p>\n","contentSnippet":"こんにちは。人事チームからエンジニアミートアップについてお知らせです。3月26日（金）19：00から、エンジニア向けのミートアップを開催することになりました！選考とは関係ないので、純粋に「どんなエンジニアがいるかみてみたい」「会社の雰囲気を知りたい」という方もぜひご参加いただけたら嬉しいです。初回のLT登壇者は @daido1976です！media.feedforce.jpご参加お待ちしています！","link":"https://developer.feedforce.jp/entry/2021/03/15/113230","isoDate":"2021-03-15T02:32:30.000Z","dateMiliSeconds":1615775550000,"imageUrl":"https://cdn.user.blog.st-hatena.com/default_entry_og_image/4268819/1588226000876991","authorName":"feedforce"}]},"__N_SSG":true}